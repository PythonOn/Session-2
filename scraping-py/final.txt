Linked List | Set 1 (Introduction).entry-headerLike arrays, Linked List is a linear data structure.  Unlike arrays, linked list elements are not stored at contiguous location; the elements are linked using pointers.Why Linked List?Arrays can be used to store linear data of similar types, but arrays have following limitations.1)The size of the arrays is fixed:  So we must know the upper limit on the number of elements in advance.  Also, generally, the allocated memory is equal to the upper limit irrespective of the usage.2)Inserting a new element in an array of elements is expensive, because room has to be created for the new elements and to create room existing elements have to shifted.For example, in a system if we maintain a sorted list of IDs in an array id[].id[] = [1000,  1010,  1050,  2000,  2040].And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000).Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.Advantages over arrays1)Dynamic size2)Ease of insertion/deletionDrawbacks:1)Random access is not allowed.  We have to access elements sequentially starting from the first node.  So we cannot do binary search with linked lists.2)Extra memory space for a pointer is required with each element of the list.Representation in C:A linked list is represented by a pointer to the first node of the linked list.  The first node is called head.  If the linked list is empty, then value of head is NULL.Each node in a list consists of at least two parts:1) data2) pointer to the next nodeIn C, we can represent a node using structures.  Below is an example of a linked list node with an integer data.In Java, LinkedList can be represented as a class and a Node as a separate class. The LinkedList class contains a reference of Node class type.C// A linked list node
struct node
{
  int data;
  struct node *next;
};Javaclass LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
         
        // Constructor to create a new node
        // Next is by default initialized as null
        Node(int d) {data = d;}
    }
}Python# Node class
class Node:
 
    # Function to initialize the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null
 
# Linked List class
class LinkedList:
   
    # Function to initialize the Linked List object
    def __init__(self): 
        self.head = NoneFirst Simple Linked List in CLet us create a simple linked list with 3 nodes.C// A simple C program to introduce a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node 
{
  int data;
  struct node *next;
};

// Program to create a simple linked list with 3 nodes
int main()
{
  struct node* head = NULL;
  struct node* second = NULL;
  struct node* third = NULL;
  
  // allocate 3 nodes in the heap  
  head = (struct node*)malloc(sizeof(struct node)); 
  second = (struct node*)malloc(sizeof(struct node));
  third = (struct node*)malloc(sizeof(struct node));

  /* Three blocks have been allocated  dynamically. 
     We have pointers to these three blocks as first, second and third     
       head           second           third
        |                |               |
        |                |               |
    +---+-----+     +----+----+     +----+----+
    | #  | #  |     | #  | #  |     |  # |  # |
    +---+-----+     +----+----+     +----+----+
   
   # represents any random value.
   Data is random because we haven’t assigned anything yet  */
  
  head-&gt;data = 1; //assign data in first node
  head-&gt;next = second; // Link first node with the second node
  
  /* data has been assigned to data part of first block (block 
    pointed by head).  And next pointer of first block points to
    second.  So they both are linked.

       head          second         third
        |              |              |
        |              |              |
    +---+---+     +----+----+     +-----+----+
    | 1  | o-----&gt;| #  | #  |     |  #  | #  |
    +---+---+     +----+----+     +-----+----+    
  */  
  
  second-&gt;data = 2; //assign data to second node
  second-&gt;next = third; // Link second node with the third node
  
  /* data has been assigned to data part of second block (block pointed by
     second). And next pointer of the second block points to third block.  
    So all three blocks are linked.
  
       head         second         third
        |             |             |
        |             |             |
    +---+---+     +---+---+     +----+----+
    | 1  | o-----&gt;| 2 | o-----&gt; |  # |  # |
    +---+---+     +---+---+     +----+----+      */    
  
  third-&gt;data = 3; //assign data to third node
  third-&gt;next = NULL;
  
  /* data has been assigned to data part of third block (block pointed
    by third). And next pointer of the third block is made NULL to indicate
    that the linked list is terminated here.

     We have the linked list ready.  

           head    
             |
             | 
        +---+---+     +---+---+       +----+------+
        | 1  | o-----&gt;|  2  | o-----&gt; |  3 | NULL |
        +---+---+     +---+---+       +----+------+       
   
    
    Note that only head is sufficient to represent the whole list.  We can 
    traverse the complete list by following next pointers.    */      

  return 0;
}Java// A simple Java program to introduce a linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node.  This inner class is made static so that
       main() can access it */
    static class Node {
        int data;
        Node next;
        Node(int d)  { data = d;  next=null; } // Constructor
    }

    /* method to create a simple linked list with 3 nodes*/
    public static void main(String[] args)
    {
        /* Start with the empty list. */
        LinkedList llist = new LinkedList();

        llist.head  = new Node(1);
        Node second = new Node(2);
        Node third  = new Node(3);

        /* Three nodes have been allocated  dynamically.
          We have refernces to these three blocks as first,  
          second and third

          llist.head        second              third
             |                |                  |
             |                |                  |
         +----+------+     +----+------+     +----+------+
         | 1  | null |     | 2  | null |     |  3 | null |
         +----+------+     +----+------+     +----+------+ */

        llist.head.next = second; // Link first node with the second node

        /*  Now next of first Node refers to second.  So they
            both are linked.

         llist.head        second              third
            |                |                  |
            |                |                  |
        +----+------+     +----+------+     +----+------+
        | 1  |  o--------&gt;| 2  | null |     |  3 | null |
        +----+------+     +----+------+     +----+------+ */

        second.next = third; // Link second node with the third node

        /*  Now next of second Node refers to third.  So all three
            nodes are linked.

         llist.head        second              third
            |                |                  |
            |                |                  |
        +----+------+     +----+------+     +----+------+
        | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |
        +----+------+     +----+------+     +----+------+ */
    }
}Python# A simple Python program to introduce a linked list

# Node class
class Node:

    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


# Code execution starts here
if __name__=='__main__':

    # Start with the empty list
    llist = LinkedList()

    llist.head  = Node(1)
    second = Node(2)
    third  = Node(3)

    '''
    Three nodes have been created.
    We have references to these three blocks as first,
    second and third

    llist.head        second              third
         |                |                  |
         |                |                  |
    +----+------+     +----+------+     +----+------+
    | 1  | None |     | 2  | None |     |  3 | None |
    +----+------+     +----+------+     +----+------+
    '''

    llist.head.next = second; # Link first node with second 

    '''
    Now next of first Node refers to second.  So they
    both are linked.

    llist.head        second              third
         |                |                  |
         |                |                  |
    +----+------+     +----+------+     +----+------+
    | 1  |  o--------&gt;| 2  | null |     |  3 | null |
    +----+------+     +----+------+     +----+------+ 
    '''

    second.next = third; # Link second node with the third node

    '''
    Now next of second Node refers to third.  So all three
    nodes are linked.

    llist.head        second              third
         |                |                  |
         |                |                  |
    +----+------+     +----+------+     +----+------+
    | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |
    +----+------+     +----+------+     +----+------+ 
    '''Linked List TraversalIn the previous program, we have created a simple linked list with three nodes.  Let us traverse the created list and print the data of each node.  For traversal, let us write a general purpose function printList() that prints any given list.C// A simple C program for traversal of a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node 
{
  int data;
  struct node *next;
};

// This function prints contents of linked list starting from 
// the given node
void printList(struct node *n)
{
  while (n != NULL)
  {
     printf(&quot; %d &quot;, n-&gt;data);
     n = n-&gt;next;
  }
}

int main()
{
  struct node* head = NULL;
  struct node* second = NULL;
  struct node* third = NULL;
  
  // allocate 3 nodes in the heap  
  head  = (struct node*)malloc(sizeof(struct node)); 
  second = (struct node*)malloc(sizeof(struct node));
  third  = (struct node*)malloc(sizeof(struct node));
 
  head-&gt;data = 1; //assign data in first node
  head-&gt;next = second; // Link first node with second   
 
  second-&gt;data = 2; //assign data to second node
  second-&gt;next = third;  
 
  third-&gt;data = 3; //assign data to third node
  third-&gt;next = NULL;
  
  printList(head);
 
  return 0;
}Java// A simple Java program for traversal of a linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node.  This inner class is made static so that
       main() can access it */
    static class Node {
        int data;
        Node next;
        Node(int d)  { data = d;  next=null; } // Constructor
    }

    /* This function prints contents of linked list starting from head */
    public void printList()
    {
        Node n = head;
        while (n != null)
        {
            System.out.print(n.data+&quot; &quot;);
            n = n.next;
        }
    }

    /* method to create a simple linked list with 3 nodes*/
    public static void main(String[] args)
    {
        /* Start with the empty list. */
        LinkedList llist = new LinkedList();

        llist.head       = new Node(1);
        Node second      = new Node(2);
        Node third       = new Node(3);

        llist.head.next = second; // Link first node with the second node
        second.next = third; // Link first node with the second node

        llist.printList();
    }
}Python# A simple Python program for traversal of a linked list

# Node class
class Node:

    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # This function prints contents of linked list
    # starting from head
    def printList(self):
        temp = self.head
        while (temp):
            print temp.data,
            temp = temp.next


# Code execution starts here
if __name__=='__main__':

    # Start with the empty list
    llist = LinkedList()

    llist.head  = Node(1)
    second = Node(2)
    third  = Node(3)

    llist.head.next = second; # Link first node with second
    second.next = third; # Link second node with the third node

    llist.printList()Output:1  2  3You may like to tryPractice MCQ Questions on Linked ListWe will soon be publishing more posts on Linked Lists.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Linked List | Set 2 (Inserting a node).entry-headerWe have introduced Linked Lists in theprevious post.  We also created a simple linked list with 3 nodes and discussed linked list traversal.All programs discussed in this post consider following representations of linked list .C// A linked list node
struct node
{
  int data;
  struct node *next;
};Java// Linked List Class
class LinkedList
{
    Node head;  // head of list

    /* Node Class */
    class Node
    {
        int data;
        Node next;
         
        // Constructor to create a new node
        Node(int d) {data = d; next = null; }
    }
}Python# Node class
class Node:

    # Function to initialize the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null

# Linked List class
class LinkedList:
  
    # Function to initialize the Linked List object
    def __init__(self): 
        self.head = NoneIn this post, methods to insert a new node in linked list are discussed. A node can be added in three ways1)At the front of the linked list2)After a given node.3)At the end of the linked list.Add a node at the front: (A 4 steps process)The new node is always added before the head of the given Linked List.  And newly added node becomes the new head of the Linked List.  For example if the given Linked List is 10->15->20->25 and we add an item 5 at the front, then the Linked List becomes 5->10->15->20->25.  Let us call the function that adds at the front of the list is push(). The push() must receive a pointer to the head pointer, because push must change the head pointer to point to the new node (Seethis)Following are the 4 steps to add node at the front.C/* Given a reference (pointer to pointer) to the head of a list
   and an int,  inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
 
    /* 2. put in the data  */
    new_node-&gt;data  = new_data;
 
    /* 3. Make next of new node as head */
    new_node-&gt;next = (*head_ref);
 
    /* 4. move the head to point to the new node */
    (*head_ref)    = new_node;
}Java/* This function is in LinkedList class. Inserts a
   new Node at front of the list. This method is 
   defined inside LinkedList class shown above */
public void push(int new_data)
{
    /* 1 &amp; 2: Allocate the Node &amp;
              Put in the data*/
    Node new_node = new Node(new_data);

    /* 3. Make next of new Node as head */
    new_node.next = head;

    /* 4. Move the head to point to new Node */
    head = new_node;
}Python# This function is in LinkedList class
# Function to insert a new node at the beginning
def push(self, new_data):

    # 1 &amp; 2: Allocate the Node &amp;
    #        Put in the data
    new_node = Node(new_data)
        
    # 3. Make next of new Node as head
    new_node.next = self.head
        
    # 4. Move the head to point to new Node 
    self.head = new_nodeTime complexity of push() is O(1) as it does constant amount of work.Add a node after a given node: (5 steps process)We are given pointer to a node, and the new node is inserted after the given node.C/* Given a node prev_node, insert a new node after the given
   prev_node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */ 
    if (prev_node == NULL) 
    { 
       printf(&quot;the given previous node cannot be NULL&quot;);       
       return;  
    }  
         
    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));
 
    /* 3. put in the data  */
    new_node-&gt;data  = new_data;
 
    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next; 
 
    /* 5. move the next of prev_node as new_node */
    prev_node-&gt;next = new_node;
}Java/* This function is in LinkedList class.
   Inserts a new node after the given prev_node. This method is 
   defined inside LinkedList class shown above */
public void insertAfter(Node prev_node, int new_data)
{
    /* 1. Check if the given Node is null */
    if (prev_node == null)
    {
        System.out.println(&quot;The given previous node cannot be null&quot;);
        return;
    }

    /* 2. Allocate the Node &amp;
       3. Put in the data*/
    Node new_node = new Node(new_data);

    /* 4. Make next of new Node as next of prev_node */
    new_node.next = prev_node.next;

    /* 5. make next of prev_node as new_node */
    prev_node.next = new_node;
}Python# This function is in LinkedList class.
# Inserts a new node after the given prev_node. This method is 
# defined inside LinkedList class shown above */
def insertAfter(self, prev_node, new_data):

    # 1. check if the given prev_node exists
    if prev_node is None:
        print &quot;The given previous node must inLinkedList.&quot;
        return

    #  2. Create new node &amp;
    #  3. Put in the data
    new_node = Node(new_data)

    # 4. Make next of new Node as next of prev_node 
    new_node.next = prev_node.next

    # 5. make next of prev_node as new_node 
    prev_node.next = new_nodeTime complexity of insertAfter() is O(1) as it does constant amount of work.Add a node at the end: (6 steps process)The new node is always added after the last node of the given Linked List.  For example if the given Linked List is 5->10->15->20->25 and we add an item 30 at the end, then the Linked List becomes 5->10->15->20->25->30.Since a Linked List is typically represented by the head of it, we have to traverse the list till end and then change the next of last node to new node.Following are the 6 steps to add node at the end.C/* Given a reference (pointer to pointer) to the head
   of a list and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/
 
    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so make next 
          of it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new node as head */
    if (*head_ref == NULL)
    {
       *head_ref = new_node;
       return;
    }  
     
    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;
 
    /* 6. Change the next of last node */
    last-&gt;next = new_node;
    return;    
}Java/* Appends a new node at the end.  This method is 
   defined inside LinkedList class shown above */
public void append(int new_data)
{
    /* 1. Allocate the Node &amp;
       2. Put in the data
       3. Set next as null */
    Node new_node = new Node(new_data);

    /* 4. If the Linked List is empty, then make the
           new node as head */
    if (head == null)
    {
        head = new Node(new_data);
        return;
    }

    /* 4. This new node is going to be the last node, so
         make next of it as null */
    new_node.next = null;

    /* 5. Else traverse till the last node */
    Node last = head; 
    while (last.next != null)
        last = last.next;

    /* 6. Change the next of last node */
    last.next = new_node;
    return;
}Python# This function is defined in Linked List class
 # Appends a new node at the end.  This method is
 #  defined inside LinkedList class shown above */
 def append(self, new_data):

    # 1. Create a new node
    # 2. Put in the data
    # 3. Set next as None
    new_node = Node(new_data)

    # 4. If the Linked List is empty, then make the
    #    new node as head
    if self.head is None:
         self.head = new_node
         return

    # 5. Else traverse till the last node
    last = self.head
    while (last.next):
        last = last.next

    # 6. Change the next of last node
    last.next =  new_nodeTime complexity of append is O(n) where n is the number of nodes in linked list.  Since there is a loop from head to end, the function does O(n) work.This method can also be optimized to work in O(1) by keeping an extra pointer to tail of linked list/Following is a complete program that uses all of the above methods to create a linked list.C// A complete working C program to demonstrate all insertion methods
// on Linked List
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
  int data;
  struct node *next;
};

/* Given a reference (pointer to pointer) to the head of a list and 
   an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. Make next of new node as head */
    new_node-&gt;next = (*head_ref);

    /* 4. move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Given a node prev_node, insert a new node after the given 
   prev_node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */
    if (prev_node == NULL)
    {
      printf(&quot;the given previous node cannot be NULL&quot;);
      return;
    }

    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));

    /* 3. put in the data  */
    new_node-&gt;data  = new_data;

    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. move the next of prev_node as new_node */
    prev_node-&gt;next = new_node;
}

/* Given a reference (pointer to pointer) to the head
   of a list and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so make next of
          it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new node as head */
    if (*head_ref == NULL)
    {
       *head_ref = new_node;
       return;
    }

    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. Change the next of last node */
    last-&gt;next = new_node;
    return;
}

// This function prints contents of linked list starting from head
void printList(struct node *node)
{
  while (node != NULL)
  {
     printf(&quot; %d &quot;, node-&gt;data);
     node = node-&gt;next;
  }
}

/* Drier program to test above functions*/
int main()
{
  /* Start with the empty list */
  struct node* head = NULL;

  // Insert 6.  So linked list becomes 6-&gt;NULL
  append(&amp;head, 6);

  // Insert 7 at the beginning. So linked list becomes 7-&gt;6-&gt;NULL
  push(&amp;head, 7);

  // Insert 1 at the beginning. So linked list becomes 1-&gt;7-&gt;6-&gt;NULL
  push(&amp;head, 1);

  // Insert 4 at the end. So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;NULL
  append(&amp;head, 4);

  // Insert 8, after 7. So linked list becomes 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NULL
  insertAfter(head-&gt;next, 8);

  printf(&quot;\n Created Linked list is: &quot;);
  printList(head);

  return 0;
}Java// A complete working Java program to demonstrate all insertion methods
// on linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d) {data = d; next = null; }
    }

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Inserts a new node after the given prev_node. */
    public void insertAfter(Node prev_node, int new_data)
    {
        /* 1. Check if the given Node is null */
        if (prev_node == null)
        {
            System.out.println(&quot;The given previous node cannot be null&quot;);
            return;
        }

        /* 2 &amp; 3: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 4. Make next of new Node as next of prev_node */
        new_node.next = prev_node.next;

        /* 5. make next of prev_node as new_node */
        prev_node.next = new_node;
    }
   
    /* Appends a new node at the end.  This method is 
       defined inside LinkedList class shown above */
    public void append(int new_data)
    {
        /* 1. Allocate the Node &amp;
           2. Put in the data
           3. Set next as null */
        Node new_node = new Node(new_data);

        /* 4. If the Linked List is empty, then make the
              new node as head */
        if (head == null)
        {
            head = new Node(new_data);
            return;
        }

        /* 4. This new node is going to be the last node, so
              make next of it as null */
        new_node.next = null;

        /* 5. Else traverse till the last node */
        Node last = head; 
        while (last.next != null)
            last = last.next;

        /* 6. Change the next of last node */
        last.next = new_node;
        return;
    }

    /* This function prints contents of linked list starting from
        the given node */
    public void printList()
    {
        Node tnode = head;
        while (tnode != null)
        {
            System.out.print(tnode.data+&quot; &quot;);
            tnode = tnode.next;
        }
    }

    /* Drier program to test above functions. Ideally this function
       should be in a separate user class.  It is kept here to keep
       code compact */
    public static void main(String[] args)
    {
        /* Start with the empty list */
        LinkedList llist = new LinkedList();

        // Insert 6.  So linked list becomes 6-&gt;NUllist
        llist.append(6);

        // Insert 7 at the beginning. So linked list becomes
        // 7-&gt;6-&gt;NUllist
        llist.push(7);

        // Insert 1 at the beginning. So linked list becomes
        // 1-&gt;7-&gt;6-&gt;NUllist
        llist.push(1);

        // Insert 4 at the end. So linked list becomes
        // 1-&gt;7-&gt;6-&gt;4-&gt;NUllist
        llist.append(4);

        // Insert 8, after 7. So linked list becomes
        // 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NUllist
        llist.insertAfter(llist.head.next, 8);

        System.out.println(&quot;\nCreated Linked list is: &quot;);
        llist.printList();
    }
}
// This code is contributed by Rajat MishraPython# A complete working Python program to demonstrate all
# insertion methods of linked list

# Node class
class Node:

    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    # Functio to insert a new node at the beginning
    def push(self, new_data):

        # 1 &amp; 2: Allocate the Node &amp;
        #        Put in the data
        new_node = Node(new_data)

        # 3. Make next of new Node as head
        new_node.next = self.head

        # 4. Move the head to point to new Node
        self.head = new_node


    # This function is in LinkedList class. Inserts a
    # new node after the given prev_node. This method is
    # defined inside LinkedList class shown above */
    def insertAfter(self, prev_node, new_data):

        # 1. check if the given prev_node exists
        if prev_node is None:
            print &quot;The given previous node must inLinkedList.&quot;
            return

        #  2. create new node &amp;
        #      Put in the data
        new_node = Node(new_data)

        # 4. Make next of new Node as next of prev_node
        new_node.next = prev_node.next

        # 5. make next of prev_node as new_node
        prev_node.next = new_node


    # This function is defined in Linked List class
    # Appends a new node at the end.  This method is
    # defined inside LinkedList class shown above */
    def append(self, new_data):

        # 1. Create a new node
        # 2. Put in the data
        # 3. Set next as None
        new_node = Node(new_data)

        # 4. If the Linked List is empty, then make the
        #    new node as head
        if self.head is None:
            self.head = new_node
            return

        # 5. Else traverse till the last node
        last = self.head
        while (last.next):
            last = last.next

        # 6. Change the next of last node
        last.next =  new_node


    # Utility function to print the linked list
    def printList(self):
        temp = self.head
        while (temp):
            print temp.data,
            temp = temp.next



# Code execution starts here
if __name__=='__main__':

    # Start with the empty list
    llist = LinkedList()

    # Insert 6.  So linked list becomes 6-&gt;None
    llist.append(6)

    # Insert 7 at the beginning. So linked list becomes 7-&gt;6-&gt;None
    llist.push(7);

    # Insert 1 at the beginning. So linked list becomes 1-&gt;7-&gt;6-&gt;None
    llist.push(1);

    # Insert 4 at the end. So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;None
    llist.append(4)

    # Insert 8, after 7. So linked list becomes 1 -&gt; 7-&gt; 8-&gt; 6-&gt; 4-&gt; None
    llist.insertAfter(llist.head.next, 8)

    print 'Created linked list is:',
    llist.printList()

# This code is contributed by Manikantan NarasimhanOutput:Created Linked list is:  1  7  8  6  4You may like to tryPractice MCQ Questions on Linked ListWe will soon be publishing more posts on Linked Lists.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Linked List | Set 3 (Deleting a node).entry-headerWe have discussedLinked List IntroductionandLinked List Insertionin previous posts on singly linked list.Let us formulate the problem statement to understand the deletion process.Given a &#8216;key&#8217;, delete the first occurrence of this key in linked list.To delete a node from linked list, we need to do following steps.1) Find previous node of the node to be deleted.2) Changed next of previous node.3) Free memory for the node to be deleted.Since every node of linked list is dynamically allocated using malloc() in C, we need to callfree()for freeing memory allocated for the node to be deleted.C/C++// A complete working C program to demonstrate deletion in singly
// linked list
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
    int data;
    struct node *next;
};

/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
    new_node-&gt;data  = new_data;
    new_node-&gt;next = (*head_ref);
    (*head_ref)    = new_node;
}

/* Given a reference (pointer to pointer) to the head of a list
   and a key, deletes the first occurrence of key in linked list */
void deleteNode(struct node **head_ref, int key)
{
    // Store head node
    struct node* temp = *head_ref, *prev;

    // If head node itself holds the key to be deleted
    if (temp != NULL &amp;&amp; temp-&gt;data == key)
    {
        *head_ref = temp-&gt;next;   // Changed head
        free(temp);               // free old head
        return;
    }

    // Search for the key to be deleted, keep track of the
    // previous node as we need to change 'prev-&gt;next'
    while (temp != NULL &amp;&amp; temp-&gt;data != key)
    {
        prev = temp;
        temp = temp-&gt;next;
    }

    // If key was not present in linked list
    if (temp == NULL) return;

    // Unlink the node from linked list
    prev-&gt;next = temp-&gt;next;

    free(temp);  // Free memory
}

// This function prints contents of linked list starting from 
// the given node
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf(&quot; %d &quot;, node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    push(&amp;head, 7);
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 2);

    puts(&quot;Created Linked List: &quot;);
    printList(head);
    deleteNode(&amp;head, 1);
    puts(&quot;\nLinked List after Deletion of 1: &quot;);
    printList(head);
    return 0;
}Java// A complete working C program to demonstrate deletion in singly
// linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d)
        {
            data = d;
            next = null;
        }
    }

    /* Given a key, deletes the first occurrence of key in linked list */
    void deleteNode(int key)
    {
        // Store head node
        Node temp = head, prev;

        // If head node itself holds the key to be deleted
        if (temp != null &amp;&amp; temp.data == key)
        {
            head = temp.next;   // Changed head
            return;
        }

        // Search for the key to be deleted, keep track of the
        // previous node as we need to change temp.next
        while (temp.next != null &amp;&amp; temp.next.data != key)
            temp = temp.next;

        // If key was not present in linked list
        if (temp == null || temp.next == null) return;

        // Unlink the node from linked list
        temp.next = temp.next.next;
    }

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        Node new_node = new Node(new_data);
        new_node.next = head;
        head = new_node;
    }

    /* This function prints contents of linked list starting from
        the given node */
    public void printList()
    {
        Node tnode = head;
        while (tnode != null)
        {
            System.out.print(tnode.data+&quot; &quot;);
            tnode = tnode.next;
        }
    }

    /* Drier program to test above functions. Ideally this function
       should be in a separate user class.  It is kept here to keep
       code compact */
    public static void main(String[] args)
    {
        LinkedList llist = new LinkedList();

        llist.push(7);
        llist.push(1);
        llist.push(3);
        llist.push(2);

        System.out.println(&quot;\nCreated Linked list is:&quot;);
        llist.printList();

        llist.deleteNode(1);  // Delete node at position 4

        System.out.println(&quot;\nLinked List after Deletion at position 4:&quot;);
        llist.printList();
    }
}Output:Created Linked List:
 2  3  1  7
Linked List after Deletion of 1:
 2  3  7Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Delete a Linked List node at a given position.entry-headerGiven a singly linked list and a position, delete a linked list node at the given position.Example:Input: position = 1, Linked List = 8->2->3->1->7
Output: Linked List =  8->3->1->7

Input: position = 0, Linked List = 8->2->3->1->7
Output: Linked List = 2->3->1->7We strongly recommend you to minimize your browser and try this yourself firstIf node to be deleted is root, simply delete it. To delete a middle node, we must have pointer to the node previous to the node to be deleted.  So if positions is not zero, we run a loop position-1 times and get pointer to the previous node.Below is C implementation of above idea.C/C++// A complete working C program to delete a node in a linked list
// at a given position
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
    int data;
    struct node *next;
};

/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
    new_node-&gt;data  = new_data;
    new_node-&gt;next = (*head_ref);
    (*head_ref)    = new_node;
}

/* Given a reference (pointer to pointer) to the head of a list
   and a position, deletes the node at the given position */
void deleteNode(struct node **head_ref, int position)
{
   // If linked list is empty
   if (*head_ref == NULL)
      return;

   // Store head node
   struct node* temp = *head_ref;

    // If head needs to be removed
    if (position == 0)
    {
        *head_ref = temp-&gt;next;   // Change head
        free(temp);               // free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i=0; temp!=NULL &amp;&amp; i&lt;position-1; i++)
         temp = temp-&gt;next;

    // If position is more than number of ndoes
    if (temp == NULL || temp-&gt;next == NULL)
         return;

    // Node temp-&gt;next is the node to be deleted
    // Store pointer to the next of node to be deleted
    struct node *next = temp-&gt;next-&gt;next;

    // Unlink the node from linked list
    free(temp-&gt;next);  // Free memory

    temp-&gt;next = next;  // Unlink the deleted node from list
}

// This function prints contents of linked list starting from
// the given node
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf(&quot; %d &quot;, node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    push(&amp;head, 7);
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 2);
    push(&amp;head, 8);

    puts(&quot;Created Linked List: &quot;);
    printList(head);
    deleteNode(&amp;head, 4);
    puts(&quot;\nLinked List after Deletion at position 4: &quot;);
    printList(head);
    return 0;
}Java// A complete working Java program to delete a node in a linked list
// at a given position
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d)
        {
            data = d;
            next = null;
        }
    }

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Given a reference (pointer to pointer) to the head of a list
       and a position, deletes the node at the given position */
    void deleteNode(int position)
    {
        // If linked list is empty
        if (head == null)
            return;

        // Store head node
        Node temp = head;

        // If head needs to be removed
        if (position == 0)
        {
            head = temp.next;   // Change head
            return;
        }

        // Find previous node of the node to be deleted
        for (int i=0; temp!=null &amp;&amp; i&lt;position-1; i++)
            temp = temp.next;

        // If position is more than number of ndoes
        if (temp == null || temp.next == null)
            return;

        // Node temp-&gt;next is the node to be deleted
        // Store pointer to the next of node to be deleted
        Node next = temp.next.next;

        temp.next = next;  // Unlink the deleted node from list
    }

    /* This function prints contents of linked list starting from
        the given node */
    public void printList()
    {
        Node tnode = head;
        while (tnode != null)
        {
            System.out.print(tnode.data+&quot; &quot;);
            tnode = tnode.next;
        }
    }

    /* Drier program to test above functions. Ideally this function
       should be in a separate user class.  It is kept here to keep
       code compact */
    public static void main(String[] args)
    {
        /* Start with the empty list */
        LinkedList llist = new LinkedList();

        llist.push(7);
        llist.push(1);
        llist.push(3);
        llist.push(2);
        llist.push(8);

        System.out.println(&quot;\nCreated Linked list is: &quot;);
        llist.printList();

        llist.deleteNode(4);  // Delete node at position 4

        System.out.println(&quot;\nLinked List after Deletion at position 4: &quot;);
        llist.printList();
    }
}Output:Created Linked List: 
 8  2  3  1  7 
Linked List after Deletion at position 4: 
 8  2  3  1Thanks toHemanth Kumarfor suggesting initial solution.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveA Programmer&#8217;s approach of looking at Array vs. Linked List.entry-headerIn general, array is considered a data structure for which size is fixed at the compile time and array memory is allocated either from Data section (e.g. global array) or Stack section (e.g. local array).Similarly, linked list is considered a data structure for which size is not fixed and memory is allocated from Heap section (e.g. using malloc() etc.) as and when needed. In this sense, array is taken as a static data structure (residing in Data or Stack section) while linked list is taken as a dynamic data structure (residing in Heap section). Memory representation of array and linked list can be visualized as follows:An array of 4 elements (integer type) which have been initialized with 1, 2, 3 and 4. Suppose, these elements are allocated at memory addresses 0x100, 0x104, 0x08 and 0x10B respectively.[(1)]       [(2)]      [(3)]      [(4)]
0x100       0x104      0x108      0x10BA linked list with 4 nodes where each node has integer as data and these data are initialized with 1, 2, 3 and 4. Suppose, these nodes are allocated via malloc() and memory allocated for them is 0x200, 0x308, 0x404 and 0x20B respectively.[(1), 0x308]     [(2),0x404]      [(3),0x20B]       [(4),NULL]  
  0x200            0x308            0x404              0x20BAnyone with even little understanding of array and linked-list might not be interested in the above explanation. I mean, it is well know that the array elements are allocated memory in sequence i.e. contiguous memory while nodes of a linked list are non-contiguous in memory. Though it sounds trivial yet this the most important difference between array and linked list. It should be noted that due to this contiguous versus non-contiguous memory, array and linked list are different. In fact, this difference is what makes array vs. linked list! In the following sections, we will try to explore on this very idea further.Since elements of array are contiguous in memory, we can access any element randomly using index e.g. intArr[3] will access directly fourth element of the array. (For newbies, array indexing start from 0 and that’s why fourth element is indexed with 3). Also, due to contiguous memory for successive elements in array, no extra information is needed to be stored in individual elements i.e. no overhead of metadata in arrays. Contrary to this, linked list nodes are non-contiguous in memory. It means that we need some mechanism to traverse or access linked list nodes. To achieve this, each node stores the location of next node and this forms the basis of the link from one node to next node. Therefore, it’s called Linked list. Though storing the location of next node is overhead in linked list but it’s required. Typically, we see linked list node declaration as follows:struct llNode
{
  int dataInt;

  /* nextNode is the pointer to next node in linked list*/
  struct llNode * nextNode;    
};So array elements are contiguous in memory and therefore not requiring any metadata. And linked list nodes are non-contiguous in memory thereby requiring metadata in the form of location of next node. Apart from this difference, we can see that array could have several unused elements because memory has already been allocated. But linked list will have only the required no. of data items. All the above information about array and linked list has been mentioned in several textbooks though in different ways.What if we need to allocate array memory from Heap section (i.e. at run time) and linked list memory from Data/Stack section. First of all, is it possible? Before that, one might ask why would someone need to do this? Now, I hope that the remaining article would make you rethink about the idea of array vs. linked-listNow consider the case when we need to store certain data in array (because array has the property of random access due to contiguous memory) but we don’t know the total size apriori. One possibility is to allocate memory of this array from Heap at run time. For example, as follows:/*At run-time, suppose we know the required size for integer array (e.g. input size from user). Say, the array size is stored in variable arrSize. Allocate this array from Heap as follows*/int * dynArr = (int *)malloc(sizeof(int)*arrSize);Though the memory of this array is allocated from Heap, the elements can still be accessed via index mechanism e.g. dynArr[i]. Basically, based on the programming problem, we have combined one benefit of array (i.e. random access of elements) and one benefit of linked list (i.e. delaying the memory allocation till run time and allocating memory from Heap). Another advantage of having this type of dynamic array is that, this method of allocating array from Heap at run time could reduce code-size (of course, it depends on certain other factors e.g. program format etc.)Now consider the case when we need to store data in a linked list (because no. of nodes in linked list would be equal to actual data items stored i.e. no extra space like array) but we aren’t allowed to get this memory from Heap again and again for each node. This might look hypothetical situation to some folks but it’s not very uncommon requirement in embedded systems. Basically, in several embedded programs, allocating memory via malloc() etc. isn’t allowed due to multiple reasons. One obvious reason is performance i.e. allocating memory via malloc() is costly in terms of time complexity because your embedded program is required to be deterministic most of the times. Another reason could be module specific memory management i.e. it’s possible that each module in embedded system manages its own memory. In short, if we need to perform our own memory management, instead of relying on system provided APIs of malloc() and free(), we might choose the linked list which is simulated using array. I hope that you got some idea why we might need to simulate linked list using array. Now, let us first see how this can be done. Suppose, type of a node in linked list (i.e. underlying array) is declared as follows:struct sllNode
{
  int dataInt;

 /*Here, note that nextIndex stores the location of next node in
  linked list*/
  int nextIndex; 
};

struct sllNode arrayLL[5];If we initialize this linked list (which is actually an array), it would look as follows in memory:[(0),-1]    [(0),-1]    [(0),-1]   [(0),-1]   [(0),-1]
0x500        0x508       0x510      0x518      0x520The important thing to notice is that all the nodes of the linked list are contiguous in memory (each one occupying 8 bytes) and nextIndex of each node is set to -1. This (i.e. -1) is done to denote that the each node of the linked list is empty as of now. This linked list is denoted by head index 0.Now, if this linked list is updated with four elements of data part 4, 3, 2 and 1 successively, it would look as follows in memory. This linked list can be viewed as 0x500 -> 0x508 -> 0x510 -> 0x518.[(1),1]       [(2),2]      [(3),3]     [(4),-2]     [(0),-1]
 0x500         0x508        0x510       0x518        0x520The important thing to notice is nextIndex of last node (i.e. fourth node) is set to -2. This (i.e. -2) is done to denote the end of linked list. Also, head node of the linked list is index 0. This concept of simulating linked list using array would look more interesting if we delete say second node from the above linked list. In that case, the linked list will look as follows in memory:[(1),2]       [(0),-1]      [(3),3]     [(4),-2]     [(0),-1]
 0x500         0x508         0x510       0x518        0x520The resultant linked list is 0x500 -> 0x510 -> 0x518. Here, it should be noted that even though we have deleted second node from our linked list, the memory for this node is still there because underlying array is still there. But the nextIndex of first node now points to third node (for which index is 2).Hopefully, the above examples would have given some idea that for the simulated linked list, we need to write our own API similar to malloc() and free() which would basically be used to insert and delete a node. Now this is what’s called own memory management. Let us see how this can be done in algorithmic manner.There are multiple ways to do so. If we take the simplistic approach of creating linked list using array,  we can use the following logic. For inserting a node, traverse the underlying array and find a node whose nextIndex is -1. It means that this node is empty. Use this node as a new node. Update the data part in this new node and set the nextIndex of this node to current head node (i.e. head index) of the linked list. Finally, make the index of this new node as head index of the linked list. To visualize it, let us take an example. Suppose the linked list is as follows where head Index is 0 i.e. linked list is 0x500 -> 0x508 -> 0x518 -> 0x520[(1),1]       [(2),3]      [(0),-1]     [(4),4]     [(5),-2]
 0x500         0x508        0x510        0x518       0x520After inserting a new node with data 8, the linked list would look as follows with head index as 2.[(1),1]       [(2),3]      [(8),0]     [(4),4]     [(5),-2]
 0x500         0x508        0x510       0x518       0x520So the linked list nodes would be at addresses 0x510 -> 0x500 -> 0x508 -> 0x518 -> 0x520For deleting a node, we need to set the nextIndex of the node as -1 so that the node is marked as empty node. But, before doing so, we need to make sure that the nextIndex of the previous node is updated correctly to index of next node of this node to be deleted. We can see that we have done own memory management for creating a linked list out of the array memory. But, this is one way of inserting and deleting nodes in this linked list. It can be easily noticed that finding an empty node is not so efficient in terms of time complexity. Basically, we’re searching the complete array linearly to find an empty node.Let us see if we can optimize it further. Basically we can maintain a linked list of empty nodes as well in the same array. In that case, the linked list would be denoted by two indexes &#8211; one index would be for linked list which has the actual data values i.e. nodes which have been inserted so far and other index would for linked list of empty nodes. By doing so, whenever, we need to insert a new node in existing linked list, we can quickly find an empty node. Let us take an example:[(4),2]    [(0),3]    [(5),5]    [(0),-1]   [(0),1]   [(9),-1]
 0x500      0x508      0x510      0x518      0x520      0x528The above linked list which is represented using two indexes (0 and 5) has two linked lists: one for actual values and another for empty nodes. The linked list with actual values has nodes at address 0x500 -> 0x510 -> 0x528 while the linked list with empty nodes has nodes at addresses 0x520 -> 0x508 -> 0x518. It can be seen that finding an empty node (i.e. writing own API similar to malloc()) should be relatively faster now because we can quickly find a free node. In real world embedded programs, a fixed chunk of memory (normally called memory pool) is allocated using malloc() only once by a module. And then the management of this memory pool (which is basically an array) is done by that module itself using techniques mentioned earlier. Sometimes, there are multiple memory pools each one having different size of node. Of course, there are several other aspects of own memory management but we’ll leave it here itself. But it’s worth mentioning that there are several methods by which the insertion (which requires our own memory allocation) and deletion (which requires our own memory freeing) can be improved further.If we look carefully, it can be noticed that the Heap section of memory is basically a big array of bytes which is being managed by the underlying operating system (OS). And OS is providing this memory management service to programmers via malloc(), free() etc. Aha !!The important take-aways from this article can be summed as follows:A) Array means contiguous memory. It can exist in any memory section be it Data or Stack or Heap.B) Linked List means non-contiguous linked memory. It can exist in any memory section be it Heap or Data or Stack.C) As a programmer, looking at a data structure from memory perspective could provide us better insight in choosing a particular data structure or even designing a new data structure. For example, we might create an array of linked lists etc.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveFind Length of a Linked List (Iterative and Recursive).entry-headerWrite a C function to count number of nodes in a given singly linked list.For example, the function should return 5 for linked list 1->3->1->2->1.Iterative Solution1) Initialize count as 0 
2) Initialize a node pointer, current = head.
3) Do following while current is not NULL
     a) current = current -> next
     b) count++;
4) Return countFollowing are C and Python implementations of above algorithm to find count of nodes.C/C++// Iterative C program to find length or count of nodes in a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Given a reference (pointer to pointer) to the head
  of a list and an int, push a new node on the front
  of the list. */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Counts no. of nodes in linked list */
int getCount(struct node* head)
{
    int count = 0;  // Initialize count
    struct node* current = head;  // Initialize current
    while (current != NULL)
    {
        count++;
        current = current-&gt;next;
    }
    return count;
}

/* Drier program to test count function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    /* Use push() to construct below list
     1-&gt;2-&gt;1-&gt;3-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 1);
    push(&amp;head, 2);
    push(&amp;head, 1);

    /* Check the count function */
    printf(&quot;count of nodes is %d&quot;, getCount(head));
    return 0;
}Python# A complete working Python program to find length of a
# Linked List iteratively

# Node class
class Node:
    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    # This function is in LinkedList class. It inserts
    # a new node at the beginning of Linked List.
    def push(self, new_data):

        # 1 &amp; 2: Allocate the Node &amp;
        #        Put in the data
        new_node = Node(new_data)

        # 3. Make next of new Node as head
        new_node.next = self.head

        # 4. Move the head to point to new Node
        self.head = new_node


    # This function counts number of nodes in Linked List
    # iteratively, given 'node' as starting node.
    def getCount(self, node):
        temp = node # Initialise temp
        count = 0 # Initialise count

        # Loop while end of linked list is not reached
        while (temp):
            count += 1
            temp = temp.next
        return count


# Code execution starts here
if __name__=='__main__':
    llist = LinkedList()
    llist.push(1)
    llist.push(3)
    llist.push(1)
    llist.push(2)
    llist.push(1)
    print ('Count of nodes is :',llist.getCount(llist.head))Output:count of nodes is 5Recursive Solutionint getCount(head)1) If head is NULL, return 0.
2) Else return 1 + getCount(head->next)Following are C and Python implementations of above algorithm to find count of nodes.C/C++// Recursive C program to find length or count of nodes in a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Given a reference (pointer to pointer) to the head
  of a list and an int, push a new node on the front
  of the list. */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Counts the no. of occurences of a node
   (search_for) in a linked list (head)*/
int getCount(struct node* head)
{
    // Base case
    if (head == NULL)
        return 0;

    // count is 1 + count of remaining list
    return 1 + getCount(head-&gt;next);
}

/* Drier program to test count function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    /* Use push() to construct below list
     1-&gt;2-&gt;1-&gt;3-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 1);
    push(&amp;head, 2);
    push(&amp;head, 1);

    /* Check the count function */
    printf(&quot;count of nodes is %d&quot;, getCount(head));
    return 0;
}Python# A complete working Python program to find length of a
# Linked List recursively

# Node class
class Node:
    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    # This function is in LinkedList class. It inserts
    # a new node at the beginning of Linked List.
    def push(self, new_data):

        # 1 &amp; 2: Allocate the Node &amp;
        #        Put in the data
        new_node = Node(new_data)

        # 3. Make next of new Node as head
        new_node.next = self.head

        # 4. Move the head to point to new Node
        self.head = new_node


    # This function counts number of nodes in Linked List
    # recursively, given 'node' as starting node.
    def getCount(self, node):
        if (not node): # Base case
            return 0
        else:
            return 1 + self.getCount(node.next)


# Code execution starts here
if __name__=='__main__':
    llist = LinkedList()
    llist.push(1)
    llist.push(3)
    llist.push(1)
    llist.push(2)
    llist.push(1)
    print 'Count of nodes is :',llist.getCount(llist.head)Output:count of nodes is 5This article is contributed byRavi. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveSearch an element in a Linked List (Iterative and Recursive).entry-headerWrite a C function that searches a given key &#8216;x&#8217; in a given singly linked list.  The function should return true if x is present in linked list and false otherwise.bool search(Node *head, int x)For example, if the key to be searched is 15 and linked list is 14->21->11->30->10, then function should return false. If key to be searched is 14, then the function should return true.Iterative Solution2) Initialize a node pointer, current = head.
3) Do following while current is not NULL
    a) current->key is equal to the key being searched return true.
    b) current = current->next
4) Return falseFollowing is iterative C implementation of above algorithm to search a given key.// Iterative C program to search an element in linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int key;
    struct node* next;
};

/* Given a reference (pointer to pointer) to the head
  of a list and an int, push a new node on the front
  of the list. */
void push(struct node** head_ref, int new_key)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the key  */
    new_node-&gt;key  = new_key;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Counts no. of nodes in linked list */
bool search(struct node* head, int x)
{
    struct node* current = head;  // Initialize current
    while (current != NULL)
    {
        if (current-&gt;key == x)
            return true;
        current = current-&gt;next;
    }
    return false;
}

/* Drier program to test count function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;
    int x = 21;

    /* Use push() to construct below list
     14-&gt;21-&gt;11-&gt;30-&gt;10  */
    push(&amp;head, 10);
    push(&amp;head, 30);
    push(&amp;head, 11);
    push(&amp;head, 21);
    push(&amp;head, 14);

    search(head, 21)? printf(&quot;Yes&quot;) : printf(&quot;No&quot;);
    return 0;
}Output:YesRecursive Solutionbool search(head, x)1) If head is NULL, return false.
2) If head's key is same as x, return true;
2) Else return search(head->next, x)Following is recursive C implementation of above algorithm to search a given key.// Recursive C program to search an element in linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int key;
    struct node* next;
};

/* Given a reference (pointer to pointer) to the head
  of a list and an int, push a new node on the front
  of the list. */
void push(struct node** head_ref, int new_key)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the key  */
    new_node-&gt;key  = new_key;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Counts no. of nodes in linked list */
bool search(struct node* head, int x)
{
    // Base case
    if (head == NULL)
        return false;
    
    // If key is present in current node, return true
    if (head-&gt;key == x)
        return true;

    // Recur for remaining list
    return search(head-&gt;next, x);
}

/* Drier program to test count function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;
    int x = 21;

    /* Use push() to construct below list
     14-&gt;21-&gt;11-&gt;30-&gt;10  */
    push(&amp;head, 10);
    push(&amp;head, 30);
    push(&amp;head, 11);
    push(&amp;head, 21);
    push(&amp;head, 14);

    search(head, 21)? printf(&quot;Yes&quot;) : printf(&quot;No&quot;);
    return 0;
}Output:YesThis article is contributed byRavi. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveCan we reverse a linked list in less than O(n)?.entry-headerIt doesn&#8217;t look possible to reverse asimple singly linked list.  Asimple singly linked list can only be reversed in O(n) time using recursive and iterative methods.Amemory efficient doubly linked listwith head and tail pointers can also be reversed in O(1) time by swapping head and tail pointers.Adoubly linked listwith head and tail pointers can also be reversed in O(1) time by swapping head and tail pointers.  But we would have to traverse the list in forward direction using prev pointer and reverse direction using next pointer which may not be considered valid.This article is contributed byAbhishek. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Insertion Sort for Singly Linked List.entry-headerWe have discussedInsertion Sort for arrays.  In this article same for linked list is discussed.Below is simple insertion sort algorithm for linked list.1) Create an empty sorted (or result) list
2) Traverse the given list, do following for every node.
......a) Insert current node in sorted way in sorted or result list.
3) Change head of given linked list to head of sorted (or result) list.The main step is (2.a) which has been covered in below post.Sorted Insert for Singly Linked ListBelow is C implementation of above algorithm/* C program for insertion sort on a linked list */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

// Function to insert a given node in a sorted linked list
void sortedInsert(struct node**, struct node*);

// function to sort a singly linked list using insertion sort
void insertionSort(struct node **head_ref)
{
    // Initialize sorted linked list
    struct node *sorted = NULL;

    // Traverse the given linked list and insert every
    // node to sorted
    struct node *current = *head_ref;
    while (current != NULL)
    {
        // Store next for next iteration
        struct node *next = current-&gt;next;

        // insert current in sorted linked list
        sortedInsert(&amp;sorted, current);

        // Update current
        current = next;
    }

    // Update head_ref to point to sorted linked list
    *head_ref = sorted;
}


/* function to insert a new_node in a list. Note that this
  function expects a pointer to head_ref as this can modify the
  head of the input linked list (similar to push())*/
void sortedInsert(struct node** head_ref, struct node* new_node)
{
    struct node* current;
    /* Special case for the head end */
    if (*head_ref == NULL || (*head_ref)-&gt;data &gt;= new_node-&gt;data)
    {
        new_node-&gt;next = *head_ref;
        *head_ref = new_node;
    }
    else
    {
        /* Locate the node before the point of insertion */
        current = *head_ref;
        while (current-&gt;next!=NULL &amp;&amp;
               current-&gt;next-&gt;data &lt; new_node-&gt;data)
        {
            current = current-&gt;next;
        }
        new_node-&gt;next = current-&gt;next;
        current-&gt;next = new_node;
    }
}

/* BELOW FUNCTIONS ARE JUST UTILITY TO TEST sortedInsert */

/* A utility function to create a new node */
struct node *newNode(int new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;
    new_node-&gt;next =  NULL;

    return new_node;
}

/* Function to print linked list */
void printList(struct node *head)
{
    struct node *temp = head;
    while(temp != NULL)
    {
        printf(&quot;%d  &quot;, temp-&gt;data);
        temp = temp-&gt;next;
    }
}

/* A utility function to insert a node at the beginning of linked list */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node = new node;

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}


// Driver program to test above functions
int main()
{
    struct node *a = NULL;
    push(&amp;a, 5);
    push(&amp;a, 20);
    push(&amp;a, 4);
    push(&amp;a, 3);
    push(&amp;a, 30);

    printf(&quot;Linked List before sorting \n&quot;);
    printList(a);

    insertionSort(&amp;a);

    printf(&quot;\nLinked List after sorting \n&quot;);
    printList(a);

    return 0;
}Linked List before sorting
30  3  4  20  5
Linked List after sorting
3  4  5  20  30Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveCircular Linked List | Set 1 (Introduction and Applications).entry-headerWe have discussed singly and doubly linked lists in the following posts.Introduction to Linked List&#038;InsertionDoubly Linked List Introduction and InsertionCircular linked listis a linked list where all nodes are connected to form a circle.  There is no NULL at the end.  A circular linked list can be a singly circular linked list or doubly circular linked list.Advantages of Circular Linked Lists:1)Any node can be a starting point.  We can traverse the whole list by starting from any point.  We just need to stop when the first visited node is visited again.2)Useful for implementation of queue. Unlikethisimplementation, we don&#8217;t need to maintain two pointers for front and rear if we use circular linked list.  We can maintain a pointer to the last inserted node and front can always be obtained as next of last.3)Circular lists are useful in applications to repeatedly go around the list. For example, when multiple applications are running on a PC, it is common for the operating system to put the running applications on a list and then to cycle through them, giving each of them a slice of time to execute, and then making them wait while the CPU is given to another application. It is convenient for the operating system to use a circular list so that when it reaches the end of the list it can cycle around to the front of the list. (Sourcehttp://web.eecs.utk.edu/~bvz/cs140/notes/Dllists/)4)Circular Doubly Linked Lists are used for implementation of advanced data structures likeFibonacci Heap.We will soon be discussing implementation of insert delete operations for circular linked lists.Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problemCircular Linked List | Set 2 (Traversal).entry-headerWe have discussedCircular Linked List Introduction and Applications,in the previous post on Circular Linked List. In this post, traversal operation is discussed.In a conventional linked list, we traverse the list from the head node and stop the traversal when we reach NULL.  In a circular linked list, we stop traversal when we reach the first node again.   Following is C code for linked list traversal./* Function to traverse a given Circular linked list and print nodes */
void printList(struct node *first)
{
    struct node *temp = first; 

    // If linked list is not empty
    if (first != NULL) 
    {
        // Keep printing nodes till we reach the first node again
        do
        {
            printf(&quot;%d &quot;, temp-&gt;data);
            temp = temp-&gt;next;
        }
        while (temp != first);
    }
}Complete C program to demonstrate traversal.Following is complete C program to demonstrate traversal of circular linked list.#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* structure for a node */
struct node
{
    int data;
    struct node *next;
};

/* Function to insert a node at the begining of a Circular
   linked list */
void push(struct node **head_ref, int data)
{
    struct node *ptr1 = (struct node *)malloc(sizeof(struct node));
    struct node *temp = *head_ref;
    ptr1-&gt;data = data;
    ptr1-&gt;next = *head_ref;

    /* If linked list is not NULL then set the next of last node */
    if (*head_ref != NULL)
    {
        while (temp-&gt;next != *head_ref)
            temp = temp-&gt;next;
        temp-&gt;next = ptr1;
    }
    else
        ptr1-&gt;next = ptr1; /*For the first node */

    *head_ref = ptr1;
}

/* Function to print nodes in a given Circular linked list */
void printList(struct node *head)
{
    struct node *temp = head;
    if (head != NULL)
    {
        do
        {
            printf(&quot;%d &quot;, temp-&gt;data);
            temp = temp-&gt;next;
        }
        while (temp != head);
    }
}

/* Driver program to test above functions */
int main()
{
    /* Initialize lists as empty */
    struct node *head = NULL;

    /* Created linked list will be 12-&gt;56-&gt;2-&gt;11 */
    push(&amp;head, 12);
    push(&amp;head, 56);
    push(&amp;head, 2);
    push(&amp;head, 11);

    printf(&quot;Contents of Circular Linked List\n &quot;);
    printList(head);

    return 0;
}Output:Contents of Circular Linked List
 11 2 56 12You may like to see following posts on Circular Linked ListSplit a Circular Linked List into two halvesSorted insert for circular linked listWe will soon be discussing implementation of insert delete operations for circular linked lists.Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problemDoubly Linked List  | Set 1 (Introduction and Insertion).entry-headerWe strongly recommend to refer following post as a prerequisite of this post.Linked List IntroductionInserting a node in Singly Linked ListADoublyLinkedList (DLL) contains an extra pointer, typically calledprevious pointer, together with next pointer and data which are there in singly linked list.Following is representation of a DLL node in C language./* Node of a doubly linked list */
struct node
{
  int data;
  struct node *next; // Pointer to next node in DLL
  struct node *prev; // Pointer to previous node in DLL  
};Following are advantages/disadvantages of doubly linked list over singly linked list.Advantages over singly linked list1)A DLL can be traversed in both forward and backward direction.2)The delete operation in DLL is more efficient if pointer to the node to be deleted is given.In singly linked list, to delete a node, pointer to the previous node is needed. To get this previous node, sometimes the list is traversed. In DLL, we can get the previous node using previous pointer.Disadvantages over singly linked list1)Every node of DLL Require extra space for an previous pointer. It is possible to implement DLL with single pointer though (Seethisandthis).2)All operations require an extra pointer previous to be maintained. For example, in insertion, we need to modify previous pointers together with next pointers.  For example in following functions for insertions at different positions, we need 1 or 2 extra steps to set previous pointer.InsertionA node can be added in four ways1)At the front of the DLL2)After a given node.3)At the end of the DLL4)Before a given node.1) Add a node at the front: (A 5 steps process)The new node is always added before the head of the given Linked List. And newly added node becomes the new head of DLL. For example if the given Linked List is 10<->15<->20<->25 and we add an item 5 at the front, then the Linked List becomes 5<->10<->15<->20<->25. Let us call the function that adds at the front of the list is push(). The push() must receive a pointer to the head pointer, because push must change the head pointer to point to the new node (Seethis)Following are the 5 steps to add node at the front./* Given a reference (pointer to pointer) to the head of a list 
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
  
    /* 2. put in the data  */
    new_node-&gt;data  = new_data;
  
    /* 3. Make next of new node as head and previous as NULL */
    new_node-&gt;next = (*head_ref);
    new_node-&gt;prev = NULL;

    /* 4. change prev of head node to new node */
    if((*head_ref) !=  NULL)
      (*head_ref)-&gt;prev = new_node ;
  
    /* 5. move the head to point to the new node */
    (*head_ref)    = new_node;
}Four steps of the above five steps are same asthe 4 steps used for inserting at the front in singly linked list.  The only extra step is to change previous of head.2) Add a node after a given node.: (A 7 steps process)We are given pointer to a node as prev_node, and the new node is inserted after the given node./* Given a node as prev_node, insert a new node after the given node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */
    if (prev_node == NULL)
    {
        printf(&quot;the given previous node cannot be NULL&quot;);
        return;
    }

    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));

    /* 3. put in the data  */
    new_node-&gt;data  = new_data;

    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. Make the next of prev_node as new_node */
    prev_node-&gt;next = new_node;

    /* 6. Make prev_node as previous of new_node */
    new_node-&gt;prev = prev_node;

    /* 7. Change previous of new_node's next node */
    if (new_node-&gt;next != NULL)
      new_node-&gt;next-&gt;prev = new_node;
}Five of the above steps step process are same asthe 5 steps used for inserting after a given node in singly linked list.  The two extra steps are needed to change previous pointer of new node and previous pointer of new node&#8217;s next node.3) Add a node at the end: (7 steps process)The new node is always added after the last node of the given Linked List. For example if the given DLL is 5<->10<->15<->20<->25 and we add an item 30 at the end, then the DLL becomes 5<->10<->15<->20<->25<->30.Since a Linked List is typically represented by the head of it, we have to traverse the list till end and then change the next of last node to new node.Following are the 7 steps to add node at the end./* Given a reference (pointer to pointer) to the head
   of a DLL and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so 
          make next of it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new
          node as head */
    if (*head_ref == NULL)
    {
        new_node-&gt;prev = NULL; 
        *head_ref = new_node;
        return;
    }

    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. Change the next of last node */
    last-&gt;next = new_node;

    /* 7. Make last node as previous of new node */
    new_node-&gt;prev = last;

    return;
}Six of the above 7 steps are same asthe 6 steps used for inserting after a given node in singly linked list.  The one extra step is needed to change previous pointer of new node.4) Add a node before a given nodeThis is left as an exercise for the readers.A complete working program to test above functions.Following is complete C program to test above functions.// A complete working C program to demonstrate all insertion methods
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
    int data;
    struct node *next;
    struct node *prev;
};

/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. Make next of new node as head and previous as NULL */
    new_node-&gt;next = (*head_ref);
    new_node-&gt;prev = NULL;

    /* 4. change prev of head node to new node */
    if((*head_ref) !=  NULL)
      (*head_ref)-&gt;prev = new_node ;

    /* 5. move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Given a node as prev_node, insert a new node after the given node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */
    if (prev_node == NULL)
    {
        printf(&quot;the given previous node cannot be NULL&quot;);
        return;
    }

    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));

    /* 3. put in the data  */
    new_node-&gt;data  = new_data;

    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. Make the next of prev_node as new_node */
    prev_node-&gt;next = new_node;

    /* 6. Make prev_node as previous of new_node */
    new_node-&gt;prev = prev_node;

    /* 7. Change previous of new_node's next node */
    if (new_node-&gt;next != NULL)
      new_node-&gt;next-&gt;prev = new_node;
}

/* Given a reference (pointer to pointer) to the head
   of a DLL and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so
          make next of it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new
          node as head */
    if (*head_ref == NULL)
    {
        new_node-&gt;prev = NULL;  
        *head_ref = new_node;
        return;
    }

    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. Change the next of last node */
    last-&gt;next = new_node;

    /* 7. Make last node as previous of new node */
    new_node-&gt;prev = last;

    return;
}

// This function prints contents of linked list starting from the given node
void printList(struct node *node)
{
    struct node *last;
    printf(&quot;\nTraversal in forward direction \n&quot;);
    while (node != NULL)
    {
        printf(&quot; %d &quot;, node-&gt;data);
        last = node;
        node = node-&gt;next;
    }

    printf(&quot;\nTraversal in reverse direction \n&quot;);
    while (last != NULL)
    {
        printf(&quot; %d &quot;, last-&gt;data);
        last = last-&gt;prev;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    // Insert 6.  So linked list becomes 6-&gt;NULL
    append(&amp;head, 6);

    // Insert 7 at the beginning. So linked list becomes 7-&gt;6-&gt;NULL
    push(&amp;head, 7);

    // Insert 1 at the beginning. So linked list becomes 1-&gt;7-&gt;6-&gt;NULL
    push(&amp;head, 1);

    // Insert 4 at the end. So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;NULL
    append(&amp;head, 4);

    // Insert 8, after 7. So linked list becomes 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NULL
    insertAfter(head-&gt;next, 8);

    printf(&quot;\n Created DLL is: &quot;);
    printList(head);

    getchar();
    return 0;
}Output:Created DLL is:
Traversal in forward direction
 1  7  8  6  4
Traversal in reverse direction
 4  6  8  7  1Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Stack | Set 1 (Introduction).entry-headerStack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out).Mainly the following three basic operations are performed in the stack:Push:Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition.Pop:Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.Peek:Get the topmost item.How to understand a stack practically?There are many real life examples of stack. Consider the simple example of plates stacked over one another in canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow LIFO/FILO order.Implementation:There are two ways to implement a stack:Using arrayUsing linked listUsing array:C// C program for array implementation of stack
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a stack
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};

// function to create a stack of given capacity. It initializes size of
// stack as 0
struct Stack* createStack(unsigned capacity)
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack-&gt;capacity = capacity;
    stack-&gt;top = -1;
    stack-&gt;array = (int*) malloc(stack-&gt;capacity * sizeof(int));
    return stack;
}

// Stack is full when top is equal to the last index
int isFull(struct Stack* stack)
{   return stack-&gt;top == stack-&gt;capacity - 1; }

// Stack is empty when top is equal to -1
int isEmpty(struct Stack* stack)
{   return stack-&gt;top == -1;  }

// Function to add an item to stack.  It increases top by 1
void push(struct Stack* stack, int item)
{
    if (isFull(stack))
        return;
    stack-&gt;array[++stack-&gt;top] = item;
    printf(&quot;%d pushed to stack\n&quot;, item);
}

// Function to remove an item from stack.  It decreases top by 1
int pop(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack-&gt;array[stack-&gt;top--];
}

// Function to get top item from stack
int peek(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack-&gt;array[stack-&gt;top];
}

// Driver program to test above functions
int main()
{
    struct Stack* stack = createStack(100);

    push(stack, 10);
    push(stack, 20);
    push(stack, 30);

    printf(&quot;%d popped from stack\n&quot;, pop(stack));

    printf(&quot;Top item is %d\n&quot;, peek(stack));

    return 0;
}Python# Python program for implementation of stack

# import maxsize from sys module 
# Used to return -infinite when stack is empty
from sys import maxsize

# Function to create a stack. It initializes size of stack as 0
def createStack():
    stack = []
    return stack

# Stack is empty when stack size is 0
def isEmpty(stack):
    return len(stack) == 0

# Function to add an item to stack. It increases size by 1
def push(stack, item):
    stack.append(item)
    print(&quot;pushed to stack &quot; + item)
    
# Function to remove an item from stack. It decreases size by 1
def pop(stack):
    if (isEmpty(stack)):
        return str(-maxsize -1) #return minus infinite
    
    return stack.pop()

# Function to get top item from stack
def peek(stack):
    if (isEmpty(stack)):
        return str(-maxsize -1)
    
    return stack[len(stack) - 1]

# Driver program to test above functions    
stack = createStack()
push(stack, str(10))
push(stack, str(20))
push(stack, str(30))
print(pop(stack) + &quot; popped from stack&quot;)
print(&quot;Top item is &quot; + peek(stack))Pros: Easy to implement. Memory is saved as pointers are not involved.Cons: It is not dynamic. It doesn’t grow and shrink depending on needs at runtime.10 pushed to stack
20 pushed to stack
30 pushed to stack
30 popped from stack
Top item is 20Linked List Implementation:// C program for linked list implementation of stack
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a stack
struct StackNode
{
    int data;
    struct StackNode* next;
};

struct StackNode* newNode(int data)
{
    struct StackNode* stackNode =
              (struct StackNode*) malloc(sizeof(struct StackNode));
    stackNode-&gt;data = data;
    stackNode-&gt;next = NULL;
    return stackNode;
}

int isEmpty(struct StackNode *root)
{
    return !root;
}

void push(struct StackNode** root, int data)
{
    struct StackNode* stackNode = newNode(data);
    stackNode-&gt;next = *root;
    *root = stackNode;
    printf(&quot;%d pushed to stack\n&quot;, data);
}

int pop(struct StackNode** root)
{
    if (isEmpty(*root))
        return INT_MIN;
    struct StackNode* temp = *root;
    *root = (*root)-&gt;next;
    int popped = temp-&gt;data;
    free(temp);

    return popped;
}

int peek(struct StackNode* root)
{
    if (isEmpty(root))
        return INT_MIN;
    return root-&gt;data;
}

int main()
{
    struct StackNode* root = NULL;

    push(&amp;root, 10);
    push(&amp;root, 20);
    push(&amp;root, 30);

    printf(&quot;%d popped from stack\n&quot;, pop(&amp;root));

    printf(&quot;Top element is %d\n&quot;, peek(root));

    return 0;
}Output:10 pushed to stack
20 pushed to stack
30 pushed to stack
30 popped from stack
Top element is 20Pros: The linked list implementation of stack can grow and shrink according to the needs at runtime.Cons: Requires extra memory due to involvement of pointers.Applications of stack:Balancing of symbols:Infix to Postfix/Prefix conversionRedo-undo features at many places like editors, photoshop.Forward and backward feature in web browsersUsed in many algorithms like Tower of Hanoi, tree traversals, stock span problem, histogram problem.Other applications can be Backtracking, Knight tour problem, rat in a maze, N queen problem and sudoku solverWe will cover the implementation of applications of stack in separate posts.Quiz:Stack QuestionsReferences:http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29#Problem_DescriptionPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Stack | Set 2 (Infix to Postfix).entry-headerInfix expression:The expression of the form a op b. When an operator is in-between every pair of operands.Postfix expression:The expression of the form a b op. When an operator is followed for every pair of operands.Why postfix representation of the expression?The compiler scans the expression either from left to right or from right to left.Consider the below expression:  a op1 b op2 c op3 dIf op1 = +, op2 = *, op3 = +The compiler first scans the expression to evaluate the expression b * c, then again scan the expression to add a to it. The result is then added to d after another scan.The repeated scanning makes it very in-efficient. It is better to convert the expression to postfix(or prefix) form before evaluation.The corresponding expression in postfix form is: abc*d++.  The postfix expressions can be evaluated easily using a stack.  We will cover postfix expression evaluation in a separate post.Algorithm1.Scan the infix expression from left to right.2.If the scanned character is an operand, output it.3.Else,&#8230;..3.1If the precedence of the scanned operator is greater than the precedence of the operator in the stack(or the stack is empty), push it.&#8230;..3.2Else, Pop the operator from the stack until the precedence of the scanned operator is less-equal to the precedence of the operator residing on the top of the stack. Push the scanned operator to the stack.4.If the scanned character is an ‘(‘, push it to the stack.5.If the scanned character is an ‘)’, pop and output from the stack until an ‘(‘ is encountered.6.Repeat steps 2-6 until infix expression is scanned.7.Pop and output from the stack until it is not empty.Following is C implementation of the above algorithm#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// Stack type
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};

// Stack Operations
struct Stack* createStack( unsigned capacity )
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));

    if (!stack) 
        return NULL;

    stack-&gt;top = -1;
    stack-&gt;capacity = capacity;

    stack-&gt;array = (int*) malloc(stack-&gt;capacity * sizeof(int));

    if (!stack-&gt;array)
        return NULL;
    return stack;
}
int isEmpty(struct Stack* stack)
{
    return stack-&gt;top == -1 ;
}
char peek(struct Stack* stack)
{
    return stack-&gt;array[stack-&gt;top];
}
char pop(struct Stack* stack)
{
    if (!isEmpty(stack))
        return stack-&gt;array[stack-&gt;top--] ;
    return '$';
}
void push(struct Stack* stack, char op)
{
    stack-&gt;array[++stack-&gt;top] = op;
}


// A utility function to check if the given character is operand
int isOperand(char ch)
{
    return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z');
}

// A utility function to return precedence of a given operator
// Higher returned value means higher precedence
int Prec(char ch)
{
    switch (ch)
    {
    case '+':
    case '-':
        return 1;

    case '*':
    case '/':
        return 2;

    case '^':
        return 3;
    }
    return -1;
}


// The main function that converts given infix expression
// to postfix expression. 
int infixToPostfix(char* exp)
{
    int i, k;
  
    // Create a stack of capacity equal to expression size 
    struct Stack* stack = createStack(strlen(exp));
    if(!stack) // See if stack was created successfully 
        return -1 ;

    for (i = 0, k = -1; exp[i]; ++i)
    {
         // If the scanned character is an operand, add it to output.
        if (isOperand(exp[i]))
            exp[++k] = exp[i];
        
        // If the scanned character is an ‘(‘, push it to the stack.
        else if (exp[i] == '(')
            push(stack, exp[i]);
       
        //  If the scanned character is an ‘)’, pop and output from the stack 
        // until an ‘(‘ is encountered.
        else if (exp[i] == ')')
        {
            while (!isEmpty(stack) &amp;&amp; peek(stack) != '(')
                exp[++k] = pop(stack);
            if (!isEmpty(stack) &amp;&amp; peek(stack) != '(')
                return -1; // invalid expression                
            else
                pop(stack);
        }
        else // an operator is encountered
        {
            while (!isEmpty(stack) &amp;&amp; Prec(exp[i]) &lt;= Prec(peek(stack)))
                exp[++k] = pop(stack);
            push(stack, exp[i]);
        }

    }

    // pop all the operators from the stack
    while (!isEmpty(stack))
        exp[++k] = pop(stack );

    exp[++k] = '&#92;&#48;';
    printf( &quot;%s\n&quot;, exp );
}

// Driver program to test above functions
int main()
{
    char exp[] = &quot;a+b*(c^d-e)^(f+g*h)-i&quot;;
    infixToPostfix(exp);
    return 0;
}Output:abcd^e-fgh*+^*+i-Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Stack | Set 4 (Evaluation of Postfix Expression).entry-headerThe Postfix notation is used to represent algebraic expressions. The expressions written in postfix form are evaluated faster compared toinfix notation as parenthesis are not required in postfix. We have discussedinfix to postfix conversion.  In this post, evaluation of postfix expressions is discussed.Following is algorithm for evaluation postfix expressions.1) Create a stack to store operands (or values).2) Scan the given expression and do following for every scanned element.&#8230;..a) If the element is a number, push it into the stack&#8230;..b) If the element is a operator, pop operands for the operator from stack. Evaluate the operator and push the result back to the stack3) When the expression is ended, the number in the stack is the final answerExample:Let the given expression be &#8220;2 3 1 * + 9 -&#8220;.  We scan all elements one by  one.1) Scan &#8216;2&#8217;, it&#8217;s a number, so push it to stack.  Stack contains &#8216;2&#8217;2) Scan &#8216;3&#8217;, again a number, push it to stack, stack now contains &#8216;2 3&#8242; (from bottom to top)3) Scan &#8216;1&#8217;, again a number, push it to stack, stack now contains &#8216;2 3 1&#8242;4) Scan &#8216;*&#8217;, it&#8217;s an operator, pop two operands from stack, apply the * operator on operands, we get 3*1 which results in 3.   We push the result &#8216;3&#8217; to stack.  Stack now becomes &#8216;2 3&#8242;.5) Scan &#8216;+&#8217;, it&#8217;s an operator, pop two operands from stack, apply the + operator on operands, we get 3 + 2 which results in 5.   We push the result &#8216;5&#8217; to stack.  Stack now becomes &#8216;5&#8217;.6) Scan &#8216;9&#8217;, it&#8217;s a number, we push it to the stack. Stack now becomes &#8216;5 9&#8242;.7) Scan &#8216;-&#8216;, it&#8217;s an operator, pop two operands from stack, apply the &#8211; operator on operands, we get 5 &#8211; 9 which results in -4.   We push the result &#8216;-4&#8242; to stack.  Stack now becomes &#8216;-4&#8242;.8) There are no more elements to scan, we return the top element from stack (which is the only element left in stack).Following is C implementation of above algorithm.// C program to evaluate value of a postfix expression
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

// Stack type
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};

// Stack Operations
struct Stack* createStack( unsigned capacity )
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));

    if (!stack) return NULL;

    stack-&gt;top = -1;
    stack-&gt;capacity = capacity;
    stack-&gt;array = (int*) malloc(stack-&gt;capacity * sizeof(int));

    if (!stack-&gt;array) return NULL;

    return stack;
}

int isEmpty(struct Stack* stack)
{
    return stack-&gt;top == -1 ;
}

char peek(struct Stack* stack)
{
    return stack-&gt;array[stack-&gt;top];
}

char pop(struct Stack* stack)
{
    if (!isEmpty(stack))
        return stack-&gt;array[stack-&gt;top--] ;
    return '$';
}

void push(struct Stack* stack, char op)
{
    stack-&gt;array[++stack-&gt;top] = op;
}


// The main function that returns value of a given postfix expression
int evaluatePostfix(char* exp)
{
    // Create a stack of capacity equal to expression size
    struct Stack* stack = createStack(strlen(exp));
    int i;

    // See if stack was created successfully
    if (!stack) return -1;

    // Scan all characters one by one
    for (i = 0; exp[i]; ++i)
    {
        // If the scanned character is an operand or number,
        // push it to the stack.
        if (isdigit(exp[i]))
            push(stack, exp[i] - '0');

        //  If the scanned character is an operator, pop two
        // elements from stack apply the operator
        else
        {
            int val1 = pop(stack);
            int val2 = pop(stack);
            switch (exp[i])
            {
             case '+': push(stack, val2 + val1); break;
             case '-': push(stack, val2 - val1); break;
             case '*': push(stack, val2 * val1); break;
             case '/': push(stack, val2/val1);   break;
            }
        }
    }
    return pop(stack);
}

// Driver program to test above functions
int main()
{
    char exp[] = &quot;231*+9-&quot;;
    printf (&quot;Value of %s is %d&quot;, exp, evaluatePostfix(exp));
    return 0;
}Output:Value of 231*+9- is -4Time complexity of evaluation algorithm is O(n) where n is number of characters in input expression.There are following limitations of above implementation.1) It supports only 4 binary operators &#8216;+&#8217;, &#8216;*&#8217;, &#8216;-&#8216; and &#8216;/&#8217;.  It can be extended for more operators by adding more switch cases.2) The allowed operands are only single digit operands.  The program can be extended for multiple digits by adding a separator like space between all elements (operators and operands) of given expression.References:http://www.cs.nthu.edu.tw/~wkhon/ds/ds10/tutorial/tutorial2.pdfPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveStack | Set 3 (Reverse a string using stack).entry-headerGiven a string, reverse it using stack.  For example &#8220;GeeksQuiz&#8221; should be converted to &#8220;ziuQskeeG&#8221;.Following is simple algorithm to reverse a string using stack.1) Create an empty stack.
2) One by one push all characters of string to stack.
3) One by one pop all characters from stack and put 
   them back to string.Following are C and Python programs that implements above algorithm.C// C program to reverse a string using stack
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a stack
struct Stack
{
    int top;
    unsigned capacity;
    char* array;
};

// function to create a stack of given capacity. It initializes size of
// stack as 0
struct Stack* createStack(unsigned capacity)
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack-&gt;capacity = capacity;
    stack-&gt;top = -1;
    stack-&gt;array = (char*) malloc(stack-&gt;capacity * sizeof(char));
    return stack;
}

// Stack is full when top is equal to the last index
int isFull(struct Stack* stack)
{   return stack-&gt;top == stack-&gt;capacity - 1; }

// Stack is empty when top is equal to -1
int isEmpty(struct Stack* stack)
{   return stack-&gt;top == -1;  }

// Function to add an item to stack.  It increases top by 1
void push(struct Stack* stack, char item)
{
    if (isFull(stack))
        return;
    stack-&gt;array[++stack-&gt;top] = item;
}

// Function to remove an item from stack.  It decreases top by 1
char pop(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack-&gt;array[stack-&gt;top--];
}

// A stack based function to reverese a string
void reverse(char str[])
{
    // Create a stack of capacity equal to length of string
    int n = strlen(str);
    struct Stack* stack = createStack(n);

    // Push all characters of string to stack
    int i;
    for (i = 0; i &lt; n; i++)
        push(stack, str[i]);

    // Pop all characters of string and put them back to str
    for (i = 0; i &lt; n; i++)
        str[i] = pop(stack);
}

// Driver program to test above functions
int main()
{
    char str[] = &quot;GeeksQuiz&quot;;

    reverse(str);
    printf(&quot;Reversed string is %s&quot;, str);

    return 0;
}Python# Python program to reverse a string using stack

# Function to create an empty stack. It initializes size of stack as 0
def createStack():
    stack=[]
    return stack

# Function to determine the size of the stack
def size(stack):
    return len(stack)

# Stack is empty if the size is 0
def isEmpty(stack):
    if size(stack) == 0:
        return true

# Function to add an item to stack . It increases size by 1    
def push(stack,item):
    stack.append(item)

#Function to remove an item from stack. It decreases size by 1
def pop(stack):
    if isEmpty(stack): return
    return stack.pop()

# A stack based function to reverse a string
def reverse(string):
    n = len(string)
    
    # Create a empty stack
    stack = createStack()

    # Push all characters of string to stack
    for i in range(0,n,1):
        push(stack,string[i])

    # Making the string empty since all characters are saved in stack    
    string=&quot;&quot;

    # Pop all characters of string and put them back to string
    for i in range(0,n,1):
        string+=pop(stack)
        
    return string
    
# Driver program to test above functions
string=&quot;GeeksQuiz&quot;
string = reverse(string)
print(&quot;Reversed string is &quot; + string)

# This code is contributed by Sunny KariraOutput:Reversed string is ziuQskeeGTime Complexity:O(n) where n is number of characters in stack.Auxiliary Space:O(n) for stack.A string can also be reversed without using any auxiliary space. Following C and Python programs to implement reverse without using stack.C// C program to reverse a string without using stack
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// A utility function to swap two characters
void swap(char *a, char *b)
{
    char temp = *a;
    *a = *b;
    *b = temp;
}

// A stack based function to reverese a string
void reverse(char str[])
{
    // get size of string
    int n = strlen(str), i;

    for (i = 0; i &lt; n/2; i++)
        swap(&amp;str[i], &amp;str[n-i-1]);
}

// Driver program to test above functions
int main()
{
    char str[] = &quot;abc&quot;;

    reverse(str);
    printf(&quot;Reversed string is %s&quot;, str);

    return 0;
}Python# Python program to reverse a string without stack

# Function to reverse a string
def reverse(string):
    string = string[::-1]
    return string

# Driver program to test above functions
string = &quot;abc&quot;
string = reverse(string)
print(&quot;Reversed string is &quot; + string)

# This code is contributed by Sunny KariraOutput:Reversed string is cbaPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Queue | Set 1 (Introduction and Array Implementation).entry-headerLikeStack,Queueis a linear structure which follows a particular order in which the operations are performed.The order isFirstInFirstOut (FIFO).  A good example of queue is any queue of consumers for a resource where the consumer that came first is served first.The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.Operations on Queue:Mainly the following four basic operations are performed on queue:Enqueue:Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.Dequeue:Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.Front:Get the front item from queue.Rear:Get the last item from queue.Applications of Queue:Queue is used when things don’t have to be processed immediatly, but have to be processed inFirstInFirstOut order likeBreadth First Search. This property of Queue makes it also useful in following kind of scenarios.1)When a resource is shared among multiple consumers. Examples include CPU scheduling, Disk Scheduling.2)When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc.Seethisfor more detailed applications of Queue and Stack.Array implementation Of QueueFor implementing queue, we need to keep track of two indices, front and rear.  We enqueue an item at the rear and dequeue an item from front. If we simply increment front and rear indices, then there may be problems, front may reach end of the array. The solution to this problem is to increase front and rear in circular manner (Seethisfor details)// C program for array implementation of queue
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a queue
struct Queue
{
    int front, rear, size;
    unsigned capacity;
    int* array;
};

// function to create a queue of given capacity. It initializes size of 
// queue as 0
struct Queue* createQueue(unsigned capacity)
{
    struct Queue* queue = (struct Queue*) malloc(sizeof(struct Queue));
    queue-&gt;capacity = capacity;
    queue-&gt;front = queue-&gt;size = 0; 
    queue-&gt;rear = capacity - 1;  // This is important, see the enqueue
    queue-&gt;array = (int*) malloc(queue-&gt;capacity * sizeof(int));
    return queue;
}

// Queue is full when size becomes equal to the capacity 
int isFull(struct Queue* queue)
{  return (queue-&gt;size == queue-&gt;capacity);  }

// Queue is empty when size is 0
int isEmpty(struct Queue* queue)
{  return (queue-&gt;size == 0); }

// Function to add an item to the queue.  It changes rear and size
void enqueue(struct Queue* queue, int item)
{
    if (isFull(queue))
        return;
    queue-&gt;rear = (queue-&gt;rear + 1)%queue-&gt;capacity;
    queue-&gt;array[queue-&gt;rear] = item;
    queue-&gt;size = queue-&gt;size + 1;
    printf(&quot;%d enqueued to queue\n&quot;, item);
}

// Function to remove an item from queue.  It changes front and size
int dequeue(struct Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    int item = queue-&gt;array[queue-&gt;front];
    queue-&gt;front = (queue-&gt;front + 1)%queue-&gt;capacity;
    queue-&gt;size = queue-&gt;size - 1;
    return item;
}

// Function to get front of queue
int front(struct Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    return queue-&gt;array[queue-&gt;front];
}

// Function to get rear of queue
int rear(struct Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    return queue-&gt;array[queue-&gt;rear];
}

// Driver program to test above functions./
int main()
{
    struct Queue* queue = createQueue(1000);

    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);
    enqueue(queue, 40);

    printf(&quot;%d dequeued from queue\n&quot;, dequeue(queue));

    printf(&quot;Front item is %d\n&quot;, front(queue));
    printf(&quot;Rear item is %d\n&quot;, rear(queue));

    return 0;
}Output:10 enqueued to queue
20 enqueued to queue
30 enqueued to queue
40 enqueued to queue
10 dequeued from queue
Front item is 20
Rear item is 40Time Complexity:Time complexity of all operations like enqueue(), dequeue(), isFull(), isEmpty(), front() and rear() is O(1). There is no loop in any of the operations.Linked list implementation is easier, we will soon be discussing linked list implementation in next article.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveQueue | Set 2 (Linked List Implementation).entry-headerIn theprevious post, we introduced Queue and discussed array implementation.In this post, linked list implementation is discussed.  The following two main operations must be implemented efficiently.In a Queue data structure, we maintain two pointers,frontandrear. Thefrontpoints the first item of queue andrearpoints to last item.enQueue()This operation adds a new node afterrearand movesrearto the next node.deQueue()This operation removes the front node and movesfrontto the next node.// A C program to demonstrate linked list based implementation of queue
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// A linked list (LL) node to store a queue entry
struct QNode
{
    int key;
    struct QNode *next;
};

// The queue, front stores the front node of LL and rear stores ths
// last node of LL
struct Queue
{
    struct QNode *front, *rear;
};

// A utility function to create a new linked list node.
struct QNode* newNode(int k)
{
    struct QNode *temp = (struct QNode*)malloc(sizeof(struct QNode));
    temp-&gt;key = k;
    temp-&gt;next = NULL;
    return temp; 
}

// A utility function to create an empty queue
struct Queue *createQueue()
{
    struct Queue *q = (struct Queue*)malloc(sizeof(struct Queue));
    q-&gt;front = q-&gt;rear = NULL;
    return q;
}

// The function to add a key k to q
void enQueue(struct Queue *q, int k)
{
    // Create a new LL node
    struct QNode *temp = newNode(k);

    // If queue is empty, then new node is front and rear both
    if (q-&gt;rear == NULL)
    {
       q-&gt;front = q-&gt;rear = temp;
       return;
    }

    // Add the new node at the end of queue and change rear
    q-&gt;rear-&gt;next = temp;
    q-&gt;rear = temp;
}

// Function to remove a key from given queue q
struct QNode *deQueue(struct Queue *q)
{
    // If queue is empty, return NULL.
    if (q-&gt;front == NULL)
       return NULL;

    // Store previous front and move front one node ahead
    struct QNode *temp = q-&gt;front;
    q-&gt;front = q-&gt;front-&gt;next;

    // If front becomes NULL, then change rear also as NULL
    if (q-&gt;front == NULL)
       q-&gt;rear = NULL;
    return temp;
}

// Driver Program to test anove functions
int main()
{
    struct Queue *q = createQueue();
    enQueue(q, 10);
    enQueue(q, 20);
    deQueue(q);
    deQueue(q);
    enQueue(q, 30);
    enQueue(q, 40);
    enQueue(q, 50);
    struct QNode *n = deQueue(q);
    if (n != NULL)
      printf(&quot;Dequeued item is %d&quot;, n-&gt;key);
    return 0;
}Output:Dequeued item is 30Time Complexity:Time complexity of both operations enqueue() and dequeue() is O(1) as we only change few pointers in both operations. There is no loop in any of the operations.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed abovePriority Queue | Set 1 (Introduction).entry-headerPriority Queue is an extension ofqueuewith following properties.1) Every item has a priority associated with it.2) An element with high priority is dequeued before an element with low priority.3) If two elements have the same priority, they are served according to their order in the queue.A typical priority queue supports following operations.insert(item, priority):Inserts an item with given priority.getHighestPriority():Returns the highest priority item.deleteHighestPriority():Removes the highest priority item.How to implement priority queue?Using Array:A simple implementation is to use array of following structure.struct item {
   int item;
   int priority;
}insert() operation can be implemented by adding an item at end of array in O(1) time.getHighestPriority() operation can be implemented by linearly searching the highest priority item in array. This operation takes O(n) time.deleteHighestPriority() operation can be implemented by first linearly searching an item, then removing the item by moving all subsequent items one position back.We can also use Linked List, time complexity of all operations with linked list remains same as array.  The advantage with linked list is deleteHighestPriority() can be more efficient as we don&#8217;t have to move items.Using Heaps:Heap is generally preferred for priority queue implementation because heaps provide better performance compared arrays or linked list. In a Binary Heap, getHighestPriority() can be implemented in O(1) time, insert() can be implemented in O(Logn) time and deleteHighestPriority() can also be implemented in O(Logn) time.WithFibonacci heap, insert() and getHighestPriority() can be implemented in O(1) amortized time and deleteHighestPriority() can be implemented in O(Logn) amortized time.Applications of Priority Queue:1) CPU Scheduling2) Graph algorithms likeDijkstra&#8217;s shortest path algorithm,Prim&#8217;s Minimum Spanning Tree, etc3) Allqueue applicationswhere priority is involved.We will soon be discussing array and heap implementations of priority queue.References:http://en.wikipedia.org/wiki/Priority_queuePlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Deque | Set 1 (Introduction and Applications).entry-headerDeque or Double Ended Queueis a generalized version ofQueue data structurethat allows insert and delete at both ends.Operations on Deque:Mainly the following four basic operations are performed on queue:insetFront(): Adds an item at the front of Deque.insertLast(): Adds an item at the rear of Deque.deleteFront(): Deletes an item from front of Deque.deleteLast(): Deletes an item from rear of Deque.In addition to above operations, following operations are also supportedgetFront(): Gets the front item from queue.getRear(): Gets the last item from queue.isEmpty(): Checks whether Deque is empty or not.isFull(): Checks whether Deque is full or not.Applications of Deque:Since Deque supports both stack and queue operations, it can be used as both.  The Deque data structure supports clockwise and anticlockwise rotations in O(1) time which can be useful in certain applications.Also, the problems where elements need to be removed and or added both ends can be efficiently solved using Deque.  For example seeMaximum of all subarrays of size k problem..Seewiki pagefor another example of A-Steal job scheduling algorithm where Deque is used as deletions operation is required at both ends.Language Support:C++ STL provides implementation of Deque asstd::dequeand Java providesDeque interface.  Seethisfor more details.Implementation:A Deque can be implemented either using adoubly linked listor circular array.   In both implementation, we can implement all operations in O(1) time.  We will soon be discussing C/C++ implementation of Deque Data structure.Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.Binary Tree | Set 1 (Introduction).entry-headerTrees:Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures.Tree Vocabulary:The topmost node is called root of the tree.  The elements that are directly under an element are called its children. The element directly above something is called its parent. For example, a is a child of f and f is the parent of a. Finally, elements with no children are called leaves.tree
      ----
       j    <-- root
     /   \
    f      k  
  /   \      \
 a     h      z    <-- leavesWhy Trees?1.One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer:file system
-----------
     /    <-- root
  /      \
...       home
      /          \
   ugrad        course
    /       /      |     \
  ...      cs101  cs112  cs1132.Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays).3.Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists).4.Like Linked Lists and unlike Arrays, Trees don’t have an upper limit on number of nodes as nodes are linked using pointers.Main applications of trees include:1.Manipulate hierarchical data.2.Make information easy to search (see tree traversal).3.Manipulate sorted lists of data.4.As a workflow for compositing digital images for visual effects.5.Router algorithms6.Form of a multi-stage decision-making (see business chess).Binary Tree:A tree whose elements have at most 2 children is called a binary tree.  Since each element in a binary tree can have only 2 children, we typically name them the left and right child.Binary Tree Representation in C:A tree is represented by a pointer to the topmost node in tree.  If the tree is empty, then value of root is NULL.A Tree node contains following parts.1. Data2. Pointer to left child3. Pointer to right childIn C, we can represent a tree node using structures.  Below is an example of a tree node with an integer data.struct node 
{
  int data;
  struct node *left;
  struct node *right;
};First Simple Tree in CLet us create a simple tree with 4 nodes in C.  The created tree would be as following.tree
      ----
       1    <-- root
     /   \
    2     3  
   /   
  4struct node 
{
    int data;
    struct node *left;
    struct node *right;
};

/* newNode() allocates a new node with the given data and NULL left and 
   right pointers. */
struct node* newNode(int data)
{
  // Allocate memory for new node 
  struct node* node = (struct node*)malloc(sizeof(struct node));

  // Assign data to this node
  node-&gt;data = data;

  // Initialize left and right children as NULL
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  return(node);
}


int main()
{
  /*create root*/
  struct node *root = newNode(1);  
  /* following is the tree after above statement 

        1
      /   \
     NULL  NULL  
  */
  

  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  /* 2 and 3 become left and right children of 1
           1
         /   \
        2      3
     /    \    /  \
    NULL NULL NULL NULL
  */


  root-&gt;left-&gt;left  = newNode(4);
  /* 4 becomes left child of 2
           1
       /       \
      2          3
    /   \       /  \
   4    NULL  NULL  NULL
  /  \
NULL NULL
*/

  getchar();
  return 0;
}Summary:Tree is a hierarchical data structure.  Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.Below are set 2 and set 3 of this post.Properties of Binary TreeTypes of Binary TreePlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Binary Tree | Set 2 (Properties).entry-headerWe have discussedIntroduction to Binary Tree in set 1. In this post, properties of binary are discussed.1) The maximum number of nodes at level &#8216;l&#8217; of a binary tree is 2l-1.Here level is number of nodes on path from root to the node (including root and node). Level of root is 1.This can be proved by induction.For root, l = 1, number of nodes = 21-1= 1Assume that maximum number of nodes on level l is 2l-1Since in Binary tree every node has at most 2 children, next level would have twice nodes, i.e. 2 * 2l-1&nbsp;2) Maximum number of nodes in a binary tree of height &#8216;h&#8217; is 2h&#8211; 1.Here height of a tree is maximum number of nodes on root to leaf path. Height of a leaf node is considered as 1.This result can be derived from point 2 above. A tree has maximum nodes if all levels have maximum nodes. So maximum number of nodes in a binary tree of height h is 1 + 2 + 4 + .. + 2h-1. This is a simple geometric series with h terms and sum of this series is 2h&#8211; 1.In some books, height of a leaf is considered as 0. In this convention, the above formula becomes 2h+1&#8211; 1&nbsp;3) In a Binary Tree with N nodes, minimum possible height or minimum number of levels is  ⌈ Log2(N+1) ⌉This can be directly derived from point 2 above. If we consider the convention where height of a leaf node is considered as 0, then above formula for minimum possible height becomes   ⌈ Log2(N+1) ⌉ &#8211; 1&nbsp;4) A Binary Tree with L leaves has at least   ⌈ Log2L ⌉ + 1   levelsA Binary tree has maximum number of leaves when all levels are fully filled.  Let all leaves be at level l, then below is true for number of leaves L.L   <=  2l-1[From Point 1]
   Log2L <=  l-1
   l >=   ⌈ Log2L ⌉ + 1&nbsp;5) In Binary tree, number of leaf nodes is always one more than nodes with two children.L = T + 1
Where L = Number of leaf nodes
      T = Number of internal nodes with two childrenSeeHandshaking Lemma and Treefor proof.In the next article on tree series, we will be discussingdifferent types of Binary Trees and their properties.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Binary Tree | Set 3 (Types of Binary Tree).entry-headerWe have discussedIntroduction to Binary Tree in set 1andProperties of Binary Tree in Set 2.  In this post, common types of binary is discussed.Following are common types of Binary Trees.Full Binary TreeA Binary Tree is full if every node has 0 or 2 children.  Following are examples of full binary tree.18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50



               18
            /     \  
          40       30  
                   /  \
                 100   40In a Full Binary, number of leaf nodes is number of internal nodes plus 1&nbsp; &nbsp;&nbsp; &nbsp; L = I + 1Where L = Number of leaf nodes,   I = Number of internal nodesSeeHandshaking Lemma and Treefor proof.Complete Binary Tree:A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possibleFollowing are examples of Complete Binary Trees18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9Practical example of Complete Binary Tree isBinary Heap.Perfect Binary TreeA Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level.Following are examples of Perfect Binaryr Trees.18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30A Perfect Binary Tree of height h (where height is number of nodes on path from root to leaf)  has 2h&#8211; 1 node.Example of Perfect binary tree is ancestors in family.   Keep a person at root, parents as children, parents of parents as their children.Balanced Binary TreeA binary tree is balanced if height of the tree is O(Log n) where n is number of nodes. For Example, AVL tree maintain O(Log n) height by making sure that the difference between heights of left and right subtrees is 1.  Red-Black trees maintain O(Log n) height by making sure that the number of Black nodes on every root to leaf paths are same and there are no adjacent red nodes.  Balanced Binary Search trees are performance wise good as they provide O(log n) time for search, insert and delete.A degenerate (or pathological) treeA Tree where every internal node has one child. Such trees are performance-wise same as linked list.10
      /
    20
     \
     30
      \
      40Source:https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_treesPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveThreaded Binary Tree.entry-headerInorder traversal of a Binary treeis either be done using recursion orwith the use of a auxiliary stack.The idea of threaded binary trees is to make inorder traversal faster and do it without stack and without recursion. A binary tree is made threaded by making all right child pointers that would normally be NULL point to the inorder successor of the node (if it exists).There are two types of threaded binary trees.Single Threaded:Where a NULL right pointers is made to point to the inorder successor (if successor exists)Double Threaded:Where both left and right NULL pointers are made to point to inorder predecessor and inorder successor respectively. The predecessor threads are useful for reverse inorder traversal and postorder traversal.The threads are also useful for fast accessing ancestors of a node.Following diagram shows an example Single Threaded Binary Tree. The dotted lines represent threads.C representation of a Threaded NodeFollowing is C representation of a single threaded node.struct Node 
{
    int data;
    Node *left, *right;
    bool rightThread;  
}Since right pointer is used for two purposes, the boolean variable rightThread is used to indicate whether right pointer points to right child or inorder successor. Similarly, we can add leftThread for a double threaded binary tree.Inorder Taversal using ThreadsFollowing is C code for inorder traversal in a threaded binary tree.// Utility function to find leftmost node in atree rooted with n
struct Node* leftMost(struct Node *n)
{
    if (n == NULL)
       return NULL;

    while (n-&gt;left != NULL)
        n = n-&gt;left;

    return n;
}

// C code to do inorder traversal in a threadded binary tree
void inOrder(struct Node *root)
{
    struct Node *cur = leftmost(root);
    while (cur != NULL)
    {
        printf(&quot;%d &quot;, cur-&gt;data);

        // If this node is a thread node, then go to
        // inorder successor
        if (cur-&gt;rightThread)
            cur = cur-&gt;right;
        else // Else go to the leftmost child in right subtree
            cur = leftmost(cur-&gt;right);
    }
}Following diagram demonstrates inorder order traversal using threads.We will soon be discussing insertion and deletion in threaded binary trees.Sources:http://en.wikipedia.org/wiki/Threaded_binary_treewww.cs.berkeley.edu/~kamil/teaching/su02/080802.pptPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveConvert left-right representation of a binary tree to down-right.entry-headerLeft-Right representationof a binary tree is standard representation where every node has a pointer to left child and another pointer to right child.Down-Right representationis an alternate representation where every node has a pointer to left (or first) child and another pointer to next sibling.  So siblings at every level are connected from left to right.Given a binary tree in left-right representation as below1
		            /    \
		           2	  3
			       /    \
 			      4      5
		             /     /   \
		            6    7      8Convert the structure of the tree to down-right representation like the below tree.1
			|
			2 – 3
			    |
			    4 — 5
			    |   |
			    6   7 – 8The conversion should happen in-place, i.e., left child pointer should be used as down pointer and right child pointer should be used as right sibling pointer.We strongly recommend to minimize your browser and try this yourself.The idea is to first convert left and right children, then convert the root.  Following is C++ implementation of the idea./* C++ program to convert left-right to down-right
   representation of binary tree */
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

// A Binary Tree Node
struct node
{
    int key;
    struct node *left, *right;
};

// An Iterative level order traversal based function to
// convert left-right to down-right representation.
void convert(node *root)
{
    // Base Case
    if (root == NULL)  return;

    // Recursively convert left an right subtrees
    convert(root-&gt;left);
    convert(root-&gt;right);

    // If left child is NULL, make right child as left
    // as it is the first child.
    if (root-&gt;left == NULL)
       root-&gt;left = root-&gt;right;

    // If left child is NOT NULL, then make right child
    // as right of left child
    else
       root-&gt;left-&gt;right = root-&gt;right;

    // Set root's right as NULL
    root-&gt;right = NULL;
}

// A utility function to traverse a tree stored in
// down-right form.
void downRightTraversal(node *root)
{
    if (root != NULL)
    {
        cout &lt;&lt; root-&gt;key &lt;&lt; &quot; &quot;;
        downRightTraversal(root-&gt;right);
        downRightTraversal(root-&gt;left);
    }
}

// Utility function to create a new tree node
node* newNode(int key)
{
    node *temp = new node;
    temp-&gt;key = key;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// Driver program to test above functions
int main()
{
    // Let us create binary tree shown in above diagram
    /*
           1
         /   \
        2     3
             / \
            4   5
           /   /  \
          6   7    8
    */
    node *root = newNode(1);
    root-&gt;left = newNode(2);
    root-&gt;right = newNode(3);
    root-&gt;right-&gt;left = newNode(4);
    root-&gt;right-&gt;right = newNode(5);
    root-&gt;right-&gt;left-&gt;left = newNode(6);
    root-&gt;right-&gt;right-&gt;left = newNode(7);
    root-&gt;right-&gt;right-&gt;right = newNode(8);

    convert(root);

    cout &lt;&lt; &quot;Traversal of the tree converted to down-right form\n&quot;;
    downRightTraversal(root);

    return 0;
}Output:Traversal of the tree converted to down-right form
1 2 3 4 5 7 8 6Time complexity of the above program is O(n).This article is contributed byAbhishek. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Print level order traversal line by line.entry-headerGiven a binary tree, print level order traversal in a way that nodes of all levels are printed in separate lines.For example consider the following tree1
       /     \
      2       3
    /   \       \
   4     5       6
        /  \     /
       7    8   9

Output for above tree should be
1
2 3
4 5 6
7 8 9Note that this is different fromsimple level order traversalwhere we need to print all nodes together. Here we need to print nodes of different levels in different lines.A simple solution is to print use the recursive function discussed in thelevel order traversal postand print a new line after every call toprintGivenLevel()./* Function to line by line print level order traversal a tree*/
void printLevelOrder(struct node* root)
{
    int h = height(root);
    int i;
    for (i=1; i&lt;=h; i++)
    {
        printGivenLevel(root, i);
        printf(&quot;\n&quot;);
    }
}

/* Print nodes at a given level */
void printGivenLevel(struct node* root, int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        printf(&quot;%d &quot;, root-&gt;data);
    else if (level &gt; 1)
    {
        printGivenLevel(root-&gt;left, level-1);
        printGivenLevel(root-&gt;right, level-1);
    }
}The time complexity of the above solution is O(n2)How to modify the iterative level order traversal (Method 2 ofthis) to levels line by line?The idea is similar tothispost. We count the nodes at current level. And for every node, we enqueue its children to queue./* Iterative program to print levels line by line */
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

// A Binary Tree Node
struct node
{
    struct node *left;
    int data;
    struct node *right;
};

// Iterative method to find height of Bianry Tree
void printLevelOrder(node *root)
{
    // Base Case
    if (root == NULL)  return;

    // Create an empty queue for level order tarversal
    queue&lt;node *&gt; q;

    // Enqueue Root and initialize height
    q.push(root);

    while (1)
    {
        // nodeCount (queue size) indicates number of nodes
        // at current lelvel.
        int nodeCount = q.size();
        if (nodeCount == 0)
            break;

        // Dequeue all nodes of current level and Enqueue all
        // nodes of next level
        while (nodeCount &gt; 0)
        {
            node *node = q.front();
            cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;
            q.pop();
            if (node-&gt;left != NULL)
                q.push(node-&gt;left);
            if (node-&gt;right != NULL)
                q.push(node-&gt;right);
            nodeCount--;
        }
        cout &lt;&lt; endl;
    }
}

// Utility function to create a new tree node
node* newNode(int data)
{
    node *temp = new node;
    temp-&gt;data = data;
    temp-&gt;left = NULL;
    temp-&gt;right = NULL;
    return temp;
}

// Driver program to test above functions
int main()
{
    // Let us create binary tree shown in above diagram
    node *root = newNode(1);
    root-&gt;left = newNode(2);
    root-&gt;right = newNode(3);
    root-&gt;left-&gt;left = newNode(4);
    root-&gt;left-&gt;right = newNode(5);
    root-&gt;right-&gt;right = newNode(6);

    printLevelOrder(root);
    return 0;
}Output:1
2 3
4 5 6Time complexity of this method is O(n) where n is number of nodes in given binary tree.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveIterative Search for a key &#8216;x&#8217; in Binary Tree.entry-headerGiven a Binary Tree and a key to be searched in it, write an iterative method that returns true if key is present in Binary Tree, else false.For example, in the following tree, if the searched key is 6, then function should return true and if the searched key is 12, then function should return false.We strongly recommend to minimize your browser and try this yourself first.One thing is sure that we need to traverse complete tree to decide whether key is present or not. We can use any of the following traversals to iteratively search a key in a given binary tree.1) IterativeLevel Order Traversal.2)Iterative Inorder Traversal3)Iterative Preorder Traversal4)Iterative Postorder TraversalBelow is iterativeLevel Order Traversalbased solution to search an item x in binary tree.// Iterative level order traversal based method to search in Binary Tree
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

/* A binary tree node has data, left child and right child */
struct node
{
    int data;
    struct node* left, *right;
};

/* Helper function that allocates a new node with the given data and
   NULL left and right  pointers.*/
struct node* newNode(int data)
{
    struct node* node = new struct node;
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return(node);
}

// An iterative process to search an element x in a given binary tree
bool iterativeSearch(node *root, int x)
{
    // Base Case
    if (root == NULL)
        return false;

    // Create an empty queue for level order traversal
    queue&lt;node *&gt; q;

    // Enqueue Root and initialize height
    q.push(root);

    // Queue based level order traversal
    while (q.empty() == false)
    {
        // See if current node is same as x
        node *node = q.front();
        if (node-&gt;data == x)
            return true;

        // Remove current node and enqueue its children
        q.pop();
        if (node-&gt;left != NULL)
            q.push(node-&gt;left);
        if (node-&gt;right != NULL)
            q.push(node-&gt;right);
    }

    return false;
}

// Driver program
int main(void)
{
    struct node*NewRoot=NULL;
    struct node *root = newNode(2);
    root-&gt;left        = newNode(7);
    root-&gt;right       = newNode(5);
    root-&gt;left-&gt;right = newNode(6);
    root-&gt;left-&gt;right-&gt;left=newNode(1);
    root-&gt;left-&gt;right-&gt;right=newNode(11);
    root-&gt;right-&gt;right=newNode(9);
    root-&gt;right-&gt;right-&gt;left=newNode(4);

    iterativeSearch(root, 6)? cout &lt;&lt; &quot;Found\n&quot;: cout &lt;&lt; &quot;Not Found\n&quot;;
    iterativeSearch(root, 12)? cout &lt;&lt; &quot;Found\n&quot;: cout &lt;&lt; &quot;Not Found\n&quot;;
    return 0;
}Output:Found
Not Found&nbsp;Below implementation usesIterative Preorder Traversalto find x in Binary Tree// An iterative method to search an item in Binary Tree
#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

/* A binary tree node has data, left child and right child */
struct node
{
    int data;
    struct node* left, *right;
};

/* Helper function that allocates a new node with the given data and
   NULL left and right  pointers.*/
struct node* newNode(int data)
{
    struct node* node = new struct node;
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return(node);
}

// iterative process to search an element x in a given binary tree
bool iterativeSearch(node *root, int x)
{
    // Base Case
    if (root == NULL)
        return false;

    // Create an empty stack and push root to it
    stack&lt;node *&gt; nodeStack;
    nodeStack.push(root);

    // Do iterative preorder traversal to search x
    while (nodeStack.empty() == false)
    {
        // See the top item from stack and check if it is same as x
        struct node *node = nodeStack.top();
        if (node-&gt;data == x)
            return true;
        nodeStack.pop();

        // Push right and left children of the popped node to stack
        if (node-&gt;right)
            nodeStack.push(node-&gt;right);
        if (node-&gt;left)
            nodeStack.push(node-&gt;left);
    }

    return false;
}

// Driver program
int main(void)
{
    struct node*NewRoot=NULL;
    struct node *root = newNode(2);
    root-&gt;left        = newNode(7);
    root-&gt;right       = newNode(5);
    root-&gt;left-&gt;right = newNode(6);
    root-&gt;left-&gt;right-&gt;left=newNode(1);
    root-&gt;left-&gt;right-&gt;right=newNode(11);
    root-&gt;right-&gt;right=newNode(9);
    root-&gt;right-&gt;right-&gt;left=newNode(4);

    iterativeSearch(root, 6)? cout &lt;&lt; &quot;Found\n&quot;: cout &lt;&lt; &quot;Not Found\n&quot;;
    iterativeSearch(root, 12)? cout &lt;&lt; &quot;Found\n&quot;: cout &lt;&lt; &quot;Not Found\n&quot;;
    return 0;
}Output:Found
Not FoundSimilarly,Iterative InorderandIterative Postordertraversals can be used.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Find maximum (or minimum) in Binary Tree.entry-headerGiven a Binary Tree, find minimum elements in it.  For example, maximum in the following Binary Tree is 11.We strongly recommend to minimize your browser and try this yourself first.In Binary Search Tree, we can find maximum by traversing right pointers until we reach rightmost node. But in Binary Tree, we must visit every node to figure out maximum. So the idea is to traverse the given tree and for every node return maximum of 3 values.1) Node&#8217;s data.2) Maximum in node&#8217;s left subtree.3) Maximum in node&#8217;s right subtree.Below is C implementation of above approach.// C program to find maximum and minimum in a Bianry Tree
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A tree node
struct node
{
    int data;
    struct node* left, *right;
};

// A utility function to create a new node
struct node* newNode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return(node);
}

// Returns maximum value in a given Binary Tree
int findMax(struct node* root)
{
    // Base case
    if (root == NULL)
      return INT_MIN;

    // Return maximum of 3 values:
    // 1) Root's data 2) Max in Left Subtree
    // 3) Max in right subtree
    int res = root-&gt;data;
    int lres = findMax(root-&gt;left);
    int rres = findMax(root-&gt;right);
    if (lres &gt; res)
      res = lres;
    if (rres &gt; res)
      res = rres;
    return res;
}

// Driver program
int main(void)
{
    struct node*NewRoot=NULL;
    struct node *root = newNode(2);
    root-&gt;left        = newNode(7);
    root-&gt;right       = newNode(5);
    root-&gt;left-&gt;right = newNode(6);
    root-&gt;left-&gt;right-&gt;left=newNode(1);
    root-&gt;left-&gt;right-&gt;right=newNode(11);
    root-&gt;right-&gt;right=newNode(9);
    root-&gt;right-&gt;right-&gt;left=newNode(4);

    printf (&quot;Maximum element is %d \n&quot;, findMax(root));

    return 0;
}Output:Maximum element is 11Similarly, we can find minimum element in Binary tree by comparing three values. Below is C function to find minimum in Binary Tree.// Returns minimum value in a given Binary Tree
int findMin(struct node* root)
{
    // Base case
    if (root == NULL)
      return INT_MAX;

    // Return minimum of 3 values:
    // 1) Root's data 2) Max in Left Subtree
    // 3) Max in right subtree
    int res = root-&gt;data;
    int lres = findMin(root-&gt;left);
    int rres = findMin(root-&gt;right);
    if (lres &lt; res)
      res = lres;
    if (rres &lt; res)
      res = rres;
    return res;
}This article is contributed byHimanshu Gupta. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Binary Search Tree | Set 1 (Search and Insertion).entry-headerThe following is definition of Binary Search Tree(BST) according toWikipediaBinary Search Tree, is a node-based binary tree data structure which has the following properties:The left subtree of a node contains only nodes with keys less than the node&#8217;s key.The right subtree of a node contains only nodes with keys greater than the node&#8217;s key.The left and right subtree each must also be a binary search tree.There must be no duplicate nodes.The above properties of Binary Search Tree provide an ordering among keys so that the operations like search, minimum and maximum can be done fast.  If there is no ordering, then we may have to compare every key to search a given key.Searching a keyTo search a given key in Bianry Search Tree, we first compare it with root, if the key is present at root, we return root.  If key is greater than root&#8217;s key, we recur for right subtree of root node.  Otherwise we recur for left subtree.C/C++// C function to search a given key in a given BST
struct node* search(struct node* root, int key)
{
    // Base Cases: root is null or key is present at root
    if (root == NULL || root-&gt;key == key)
       return root;
   
    // Key is greater than root's key
    if (root-&gt;key &lt; key)
       return search(root-&gt;right, key);

    // Key is smaller than root's key
    return search(root-&gt;left, key);
}Python# A utility function to search a given key in BST
def search(root,key):
    
    # Base Cases: root is null or key is present at root
    if root is None or root.val == key:
        return root

    # Key is greater than root's key
    if root.val &lt; key:
        return search(root.right,key)
  
    # Key is smaller than root's key
    return search(root.left,key)

# This code is contributed by Bhavya JainJava// A utility function to search a given key in BST
public Node search(Node root, int key)
{
    // Base Cases: root is null or key is present at root
    if (root==null || root.key==key)
        return root;

    // val is greater than root's key
    if (root.key &gt; key)
        return search(root.left, key);

    // val is less than root's key
    return search(root.right, key);
}Insertion of a keyA new key is always inserted at leaf.  We start searching a key from root till we hit a leaf node.  Once a leaf node is found, the new node is added as a child of the leaf node.100                               100
        /   \        Insert 40            /    \
      20     500    --------->          20     500 
     /  \                              /  \  
    10   30                           10   30
                                              \   
                                              40C/C++// C program to demonstrate insert operation in binary search tree
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
 
struct node
{
    int key;
    struct node *left, *right;
};
 
// A utility function to create a new BST node
struct node *newNode(int item)
{
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}
 
// A utility function to do inorder traversal of BST
void inorder(struct node *root)
{
    if (root != NULL)
    {
        inorder(root-&gt;left);
        printf(&quot;%d \n&quot;, root-&gt;key);
        inorder(root-&gt;right);
    }
}
 
/* A utility function to insert a new node with given key in BST */
struct node* insert(struct node* node, int key)
{
    /* If the tree is empty, return a new node */
    if (node == NULL) return newNode(key);

    /* Otherwise, recur down the tree */
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else if (key &gt; node-&gt;key)
        node-&gt;right = insert(node-&gt;right, key);   

    /* return the (unchanged) node pointer */
    return node;
}
 
// Driver Program to test above functions
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    struct node *root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // print inoder traversal of the BST
    inorder(root);
 
    return 0;
}Python# Python program to demonstrate insert operation in binary search tree 

# A utility class that represents an individual node in a BST
class Node:
	def __init__(self,key):
		self.left = None
		self.right = None
		self.val = key

# A utility function to insert a new node with the given key
def insert(root,node):
	if root is None:
		root = node
	else:
		if root.val &lt; node.val:
			if root.right is None:
				root.right = node
			else:
				insert(root.right, node)
		else:
			if root.left is None:
				root.left = node
			else:
				insert(root.left, node)

# A utility function to do inorder tree traversal
def inorder(root):
	if root:
		inorder(root.left)
		print(root.val)
		inorder(root.right)


# Driver program to test the above functions
# Let us create the following BST
#      50
#    /	  \
#   30     70
#   / \    / \
#  20 40  60 80
r = Node(50)
insert(r,Node(30))
insert(r,Node(20))
insert(r,Node(40))
insert(r,Node(70))
insert(r,Node(60))
insert(r,Node(80))

# Print inoder traversal of the BST
inorder(r)

# This code is contributed by Bhavya JainJava// Java program to demonstrate insert operation in binary search tree
class BinarySearchTree {

    /* Class containing left and right child of current node and key value*/
    class Node {
        int key;
        Node left, right;

        public Node(int item) {
            key = item;
            left = right = null;
        }
    }

    // Root of BST
    Node root;

    // Constructor
    BinarySearchTree() { 
        root = null; 
    }

    // This method mainly calls insertRec()
    void insert(int key) {
       root = insertRec(root, key);
    }
    
    /* A recursive function to insert a new key in BST */
    Node insertRec(Node root, int key) {

        /* If the tree is empty, return a new node */
        if (root == null) {
            root = new Node(key);
            return root;
        }

        /* Otherwise, recur down the tree */
        if (key &lt; root.key)
            root.left = insertRec(root.left, key);
        else if (key &gt; root.key)
            root.right = insertRec(root.right, key);

        /* return the (unchanged) node pointer */
        return root;
    }

    // This method mainly calls InorderRec()
    void inorder()  {
       inorderRec(root);
    }

    // A utility function to do inorder traversal of BST
    void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.println(root.key);
            inorderRec(root.right);
        }
    }

    // Driver Program to test above functions
    public static void main(String[] args) {
        BinarySearchTree tree = new BinarySearchTree();

        /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        // print inorder traversal of the BST
        tree.inorder();
    }
}
// This code is contributed by Ankur Narain VermaOutput:20
30
40
50
60
70
80Time Complexity:The worst case time complexity of search and insert operations is O(h) where h is height of Binary Search Tree.  In worst case, we may have to travel from root to the deepest leaf node.  The height of a skewed tree may become n and the time complexity of search and insert operation may become O(n).Binary Search Tree Delete OperationQuiz on Binary Search TreePlease write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveBinary Search Tree | Set 2 (Delete).entry-headerWe have discussedBST search and insert operations.  In this post, delete operation is discussed.  When we delete a node, there possibilities arise.1)Node to be deleted is leaf:Simply remove from the tree.50                            50
           /     \         delete(20)      /   \
          30      70       --------->    30     70 
         /  \    /  \                     \    /  \ 
       20   40  60   80                   40  60   802)Node to be deleted has only one child:Copy the child to the node and delete the child50                            50
           /     \         delete(30)      /   \
          30      70       --------->    40     70 
            \    /  \                          /  \ 
            40  60   80                       60   803)Node to be deleted has two children:Find inorder successor of the node. Copy contents of the inorder successor to the node and delete the inorder successor. Note that inorder predecessor can also be used.50                            60
           /     \         delete(50)      /   \
          40      70       --------->    40    70 
                 /  \                            \ 
                60   80                           80The important thing to note is, inorder successor is needed only when right child is not empty.  In this particular case, inorder successor can be obtained by finding the minimum value in right child of the node.C/C++// C program to demonstrate delete operation in binary search tree
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node
{
    int key;
    struct node *left, *right;
};

// A utility function to create a new BST node
struct node *newNode(int item)
{
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// A utility function to do inorder traversal of BST
void inorder(struct node *root)
{
    if (root != NULL)
    {
        inorder(root-&gt;left);
        printf(&quot;%d &quot;, root-&gt;key);
        inorder(root-&gt;right);
    }
}

/* A utility function to insert a new node with given key in BST */
struct node* insert(struct node* node, int key)
{
    /* If the tree is empty, return a new node */
    if (node == NULL) return newNode(key);

    /* Otherwise, recur down the tree */
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else
        node-&gt;right = insert(node-&gt;right, key);

    /* return the (unchanged) node pointer */
    return node;
}

/* Given a non-empty binary search tree, return the node with minimum
   key value found in that tree. Note that the entire tree does not
   need to be searched. */
struct node * minValueNode(struct node* node)
{
    struct node* current = node;

    /* loop down to find the leftmost leaf */
    while (current-&gt;left != NULL)
        current = current-&gt;left;

    return current;
}

/* Given a binary search tree and a key, this function deletes the key
   and returns the new root */
struct node* deleteNode(struct node* root, int key)
{
    // base case
    if (root == NULL) return root;

    // If the key to be deleted is smaller than the root's key,
    // then it lies in left subtree
    if (key &lt; root-&gt;key)
        root-&gt;left = deleteNode(root-&gt;left, key);

    // If the key to be deleted is greater than the root's key,
    // then it lies in right subtree
    else if (key &gt; root-&gt;key)
        root-&gt;right = deleteNode(root-&gt;right, key);

    // if key is same as root's key, then This is the node
    // to be deleted
    else
    {
        // node with only one child or no child
        if (root-&gt;left == NULL)
        {
            struct node *temp = root-&gt;right;
            free(root);
            return temp;
        }
        else if (root-&gt;right == NULL)
        {
            struct node *temp = root-&gt;left;
            free(root);
            return temp;
        }

        // node with two children: Get the inorder successor (smallest
        // in the right subtree)
        struct node* temp = minValueNode(root-&gt;right);

        // Copy the inorder successor's content to this node
        root-&gt;key = temp-&gt;key;

        // Delete the inorder successor
        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);
    }
    return root;
}

// Driver Program to test above functions
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    struct node *root = NULL;
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    printf(&quot;Inorder traversal of the given tree \n&quot;);
    inorder(root);

    printf(&quot;\nDelete 20\n&quot;);
    root = deleteNode(root, 20);
    printf(&quot;Inorder traversal of the modified tree \n&quot;);
    inorder(root);

    printf(&quot;\nDelete 30\n&quot;);
    root = deleteNode(root, 30);
    printf(&quot;Inorder traversal of the modified tree \n&quot;);
    inorder(root);

    printf(&quot;\nDelete 50\n&quot;);
    root = deleteNode(root, 50);
    printf(&quot;Inorder traversal of the modified tree \n&quot;);
    inorder(root);

    return 0;
}Java// Java program to demonstrate delete operation in binary search tree
class BinarySearchTree
{
    /* Class containing left and right child of current node and key value*/
    class Node
    {
        int key;
        Node left, right;

        public Node(int item)
        {
            key = item;
            left = right = null;
        }
    }

    // Root of BST
    Node root;

    // Constructor
    BinarySearchTree()
    {
        root = null;
    }

    // This method mainly calls deleteRec()
    void deleteKey(int key)
    {
        root = deleteRec(root, key);
    }

    /* A recursive function to insert a new key in BST */
    Node deleteRec(Node root, int key)
    {
        /* Base Case: If the tree is empty */
        if (root == null)  return root;

        /* Otherwise, recur down the tree */
        if (key &lt; root.key)
            root.left = deleteRec(root.left, key);
        else if (key &gt; root.key)
            root.right = deleteRec(root.right, key);

        // if key is same as root's key, then This is the node
        // to be deleted
        else
        {
            // node with only one child or no child
            if (root.left == null)
                return root.right;
            else if (root.right == null)
                return root.left;

            // node with two children: Get the inorder successor (smallest
            // in the right subtree)
            root.key = minValue(root.right);

            // Delete the inorder successor
            root.right = deleteRec(root.right, root.key);
        }

        return root;
    }

    int minValue(Node root)
    {
        int minv = root.key;
        while (root.left != null)
        {
            minv = root.left.key;
            root = root.left;
        }
        return minv;
    }

    // This method mainly calls insertRec()
    void insert(int key)
    {
        root = insertRec(root, key);
    }

    /* A recursive function to insert a new key in BST */
    Node insertRec(Node root, int key)
    {

        /* If the tree is empty, return a new node */
        if (root == null)
        {
            root = new Node(key);
            return root;
        }

        /* Otherwise, recur down the tree */
        if (key &lt; root.key)
            root.left = insertRec(root.left, key);
        else if (key &gt; root.key)
            root.right = insertRec(root.right, key);

        /* return the (unchanged) node pointer */
        return root;
    }

    // This method mainly calls InorderRec()
    void inorder()
    {
        inorderRec(root);
    }

    // A utility function to do inorder traversal of BST
    void inorderRec(Node root)
    {
        if (root != null)
        {
            inorderRec(root.left);
            System.out.print(root.key + &quot; &quot;);
            inorderRec(root.right);
        }
    }

    // Driver Program to test above functions
    public static void main(String[] args)
    {
        BinarySearchTree tree = new BinarySearchTree();

        /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
        20   40  60   80 */
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        System.out.println(&quot;Inorder traversal of the given tree&quot;);
        tree.inorder();

        System.out.println(&quot;\nDelete 20&quot;);
        tree.deleteKey(20);
        System.out.println(&quot;Inorder traversal of the modified tree&quot;);
        tree.inorder();

        System.out.println(&quot;\nDelete 30&quot;);
        tree.deleteKey(30);
        System.out.println(&quot;Inorder traversal of the modified tree&quot;);
        tree.inorder();

        System.out.println(&quot;\nDelete 50&quot;);
        tree.deleteKey(50);
        System.out.println(&quot;Inorder traversal of the modified tree&quot;);
        tree.inorder();
    }
}Output:Inorder traversal of the given tree
20 30 40 50 60 70 80
Delete 20
Inorder traversal of the modified tree
30 40 50 60 70 80
Delete 30
Inorder traversal of the modified tree
40 50 60 70 80
Delete 50
Inorder traversal of the modified tree
40 60 70 80Time Complexity:The worst case time complexity of delete operation is O(h) where h is height of Binary Search Tree. In worst case, we may have to travel from root to the deepest leaf node. The height of a skewed tree may become n and the time complexity of delete operation may become O(n)Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveBinary Heap.entry-headerA Binary Heap is a Binary Tree with following properties.1) It&#8217;s a complete tree (All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array.2) A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to Min Heap.Examples of Min Heap:10                      10
         /      \               /       \  
       20        100          15         30  
      /                      /  \        /  \
    30                     40    50    100   40Applications of Heaps:1)Heap Sort: Heap Sort uses Binary Heap to sort an array in O(nLogn) time.2)Priority Queue:Priority queues can be efficiently implemented using Binary Heap because it supports insert(), delete() and extractmax(), decreaseKey() operations in O(logn) time. Binomoial Heap and Fibonacci Heap are variations of Binary Heap. These variations perform union also efficiently.3)Graph Algorithms: The priority queues are especially used in Graph Algorithms likeDijkstra&#8217;s Shortest PathandPrim&#8217;s Minimum Spanning Tree.4)Many problems can be efficiently solved using Heaps.  See following for example.a)K&#8217;th Largest Element in an array.b)Sort an almost sorted array/c)Merge K Sorted Arrays.Operations on Min Heap:1)getMini():  It returns the root element of Min Heap.  Time Complexity of this operation is O(1).2)extractMin(): Removes the minimum element from Min Heap. Time Complexity of this Operation is O(Logn) as this operation needs to maintain the heap property (by calling heapify()) after removing root.3)decreaseKey():  Decreases value of key. Time complexity of this operation is O(Logn). If the decreases key value of a node is greater than parent of the node, then we don&#8217;t need to do anything. Otherwise, we need to traverse up to fix the violated heap property.4)insert(): Inserting a new key takes O(Logn) time.  We add a new key at the end of the tree. IF new key is greater than its parent, then we don&#8217;t need to do anything. Otherwise, we need to traverse up to fix the violated heap property.5)delete(): Deleting a key also takes O(Logn) time. We replace the key to be deleted with minum infinite by calling decreaseKey().  After decreaseKey(), the minus infinite value must reach root, so we call extractMin() to remove key.Following is C++ implementation of basic heap operations.// A C++ program to demonstrate common Binary Heap Operations
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

// Prototype of a utility function to swap two integers
void swap(int *x, int *y);

// A class for Min Heap
class MinHeap
{
    int *harr; // pointer to array of elements in heap
    int capacity; // maximum possible size of min heap
    int heap_size; // Current number of elements in min heap
public:
    // Constructor
    MinHeap(int capacity);

    // to heapify a subtree with root at given index
    void MinHeapify(int );

    int parent(int i) { return (i-1)/2; }

    // to get index of left child of node at index i
    int left(int i) { return (2*i + 1); }

    // to get index of right child of node at index i
    int right(int i) { return (2*i + 2); }

    // to extract the root which is the minimum element
    int extractMin();

    // Decreases key value of key at index i to new_val
    void decreaseKey(int i, int new_val);

    // Returns the minimum key (key at root) from min heap
    int getMin() { return harr[0]; }

    // Deletes a key stored at index i
    void deleteKey(int i);

    // Inserts a new key 'k'
    void insertKey(int k);
};

// Constructor: Builds a heap from a given array a[] of given size
MinHeap::MinHeap(int cap)
{
    heap_size = 0;
    capacity = cap;
    harr = new int[cap];
}

// Inserts a new key 'k'
void MinHeap::insertKey(int k)
{
    if (heap_size == capacity)
    {
        cout &lt;&lt; &quot;\nOverflow: Could not insertKey\n&quot;;
        return;
    }

    // First insert the new key at the end
    heap_size++;
    int i = heap_size - 1;
    harr[i] = k;

    // Fix the min heap property if it is violated
    while (i != 0 &amp;&amp; harr[parent(i)] &gt; harr[i])
    {
       swap(&amp;harr[i], &amp;harr[parent(i)]);
       i = parent(i);
    }
}

// Decreases value of key at index 'i' to new_val.  It is assumed that
// new_val is smaller than harr[i].
void MinHeap::decreaseKey(int i, int new_val)
{
    harr[i] = new_val;
    while (i != 0 &amp;&amp; harr[parent(i)] &gt; harr[i])
    {
       swap(&amp;harr[i], &amp;harr[parent(i)]);
       i = parent(i);
    }
}

// Method to remove minimum element (or root) from min heap
int MinHeap::extractMin()
{
    if (heap_size &lt;= 0)
        return INT_MAX;
    if (heap_size == 1)
    {
        heap_size--;
        return harr[0];
    }

    // Store the minimum vakue, and remove it from heap
    int root = harr[0];
    harr[0] = harr[heap_size-1];
    heap_size--;
    MinHeapify(0);

    return root;
}


// This function deletes key at index i. It first reduced value to minus
// infinite, then calls extractMin()
void MinHeap::deleteKey(int i)
{
    decreaseKey(i, INT_MIN);
    extractMin();
}

// A recursive method to heapify a subtree with root at given index
// This method assumes that the subtrees are already heapified
void MinHeap::MinHeapify(int i)
{
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l &lt; heap_size &amp;&amp; harr[l] &lt; harr[i])
        smallest = l;
    if (r &lt; heap_size &amp;&amp; harr[r] &lt; harr[smallest])
        smallest = r;
    if (smallest != i)
    {
        swap(&amp;harr[i], &amp;harr[smallest]);
        MinHeapify(smallest);
    }
}

// A utility function to swap two elements
void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Driver program to test above functions
int main()
{
    MinHeap h(11);
    h.insertKey(3);
    h.insertKey(2);
    h.deleteKey(1);
    h.insertKey(15);
    h.insertKey(5);
    h.insertKey(4);
    h.insertKey(45);
    cout &lt;&lt; h.extractMin() &lt;&lt; &quot; &quot;;
    cout &lt;&lt; h.getMin() &lt;&lt; &quot; &quot;;
    h.decreaseKey(2, 1);
    cout &lt;&lt; h.getMin();
    return 0;
}Output:2 4 1Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Heap Sort.entry-headerHeap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end.  We repeat the same process for remaining element.What is Binary Heap?Let us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (SourceWikipedia)A Binary Heap is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes.  The former is called as max heap  and the latter is called min heap. The heap can be represented by binary tree or array.Why array based representation for Binary Heap?Since a Binary Heap is a Complete Binary Tree, it can be easily represented as array and array based representation is space efficient. If the parent node is stored at index I, the left child can be calculated by 2 * I + 1 and right child by 2 * I + 2.Heap Sort Algorithm for sorting in increasing order:1.Build a max heap from the input data.2.At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.3.Repeat above steps until size of heap is greater than 1.How to build the heap?Heapify procedure can be applied to a node only if its children nodes are heapified.  So the heapification must be performed in the bottom up order.Lets understand with the help of an example:Input data: 4, 10, 3, 5, 1
                 4(0)
		/   \
	     10(1)   3(2)
            /   \
	 5(3)    1(4)

The numbers in bracket represent the indices in the array 
representation of data.

Applying heapify procedure to index 1:
 		4(0)
		/   \
            10(1)    3(2)
           /   \
	5(3)    1(4)

Applying heapify procedure to index 0:
	        10(0)
		/  \
	     5(1)  3(2)
            /   \
         4(3)    1(4)
The heapify procedure calls itself recursively to build heap
 in top down manner.// C implementation of Heap Sort
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A heap has current size and array of elements
struct MaxHeap
{
    int size;
    int* array;
};

// A utility function to swap to integers
void swap(int* a, int* b) { int t = *a; *a = *b;  *b = t; }

// The main function to heapify a Max Heap. The function 
// assumes that everything under given root (element at 
// index idx) is already heapified
void maxHeapify(struct MaxHeap* maxHeap, int idx)
{
    int largest = idx;  // Initialize largest as root
    int left = (idx &lt;&lt; 1) + 1;  // left = 2*idx + 1
    int right = (idx + 1) &lt;&lt; 1; // right = 2*idx + 2

    // See if left child of root exists and is greater than
    // root
    if (left &lt; maxHeap-&gt;size &amp;&amp; 
        maxHeap-&gt;array[left] &gt; maxHeap-&gt;array[largest])
        largest = left;

    // See if right child of root exists and is greater than
    // the largest so far
    if (right &lt; maxHeap-&gt;size &amp;&amp; 
        maxHeap-&gt;array[right] &gt; maxHeap-&gt;array[largest])
        largest = right;

    // Change root, if needed
    if (largest != idx)
    {
        swap(&amp;maxHeap-&gt;array[largest], &amp;maxHeap-&gt;array[idx]);
        maxHeapify(maxHeap, largest);
    }
}

// A utility function to create a max heap of given capacity
struct MaxHeap* createAndBuildHeap(int *array, int size)
{
    int i;
    struct MaxHeap* maxHeap = 
              (struct MaxHeap*) malloc(sizeof(struct MaxHeap));
    maxHeap-&gt;size = size;   // initialize size of heap
    maxHeap-&gt;array = array; // Assign address of first element of array

    // Start from bottommost and rightmost internal mode and heapify all
    // internal modes in bottom up way
    for (i = (maxHeap-&gt;size - 2) / 2; i &gt;= 0; --i)
        maxHeapify(maxHeap, i);
    return maxHeap;
}

// The main function to sort an array of given size
void heapSort(int* array, int size)
{
    // Build a heap from the input data.
    struct MaxHeap* maxHeap = createAndBuildHeap(array, size);

    // Repeat following steps while heap size is greater than 1. 
    // The last element in max heap will be the minimum element
    while (maxHeap-&gt;size &gt; 1)
    {
        // The largest item in Heap is stored at the root. Replace
        // it with the last item of the heap followed by reducing the
        // size of heap by 1.
        swap(&amp;maxHeap-&gt;array[0], &amp;maxHeap-&gt;array[maxHeap-&gt;size - 1]);
        --maxHeap-&gt;size;  // Reduce heap size

        // Finally, heapify the root of tree.
        maxHeapify(maxHeap, 0);
    }
}

// A utility function to print a given array of given size
void printArray(int* arr, int size)
{
    int i;
    for (i = 0; i &lt; size; ++i)
        printf(&quot;%d &quot;, arr[i]);
}

/* Driver program to test above functions */
int main()
{
    int arr[] = {12, 11, 13, 5, 6, 7};
    int size = sizeof(arr)/sizeof(arr[0]);

    printf(&quot;Given array is \n&quot;);
    printArray(arr, size);

    heapSort(arr, size);

    printf(&quot;\nSorted array is \n&quot;);
    printArray(arr, size);
    return 0;
}Output:Given array is
12 11 13 5 6 7
Sorted array is
5 6 7 11 12 13Notes:Heap sort is an in-place algorithm.Its typical implementation is not stable, but can be made stable (Seethis)Time Complexity:Time complexity of heapify is O(Logn).  Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn).Applications of HeapSort1.Sort a nearly sorted (or K sorted) array2.k largest(or smallest) elements in an arrayHeap sort algorithm has limited uses because Quicksort and Mergesort are better in practice. Nevertheless, the Heap data structure itself is enormously used. SeeApplications of Heap Data StructureOther Sorting Algorithms on GeeksforGeeks/GeeksQuiz:Selection SortBubble SortInsertion SortMerge SortQuickSortRadix SortCounting SortBucket SortShellSortPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Hashing | Set 1 (Introduction).entry-headerSuppose we want to design a system for storing employee records keyed using phone numbers. And we want following queries to be performed efficiently:Insert a phone number and corresponding information.Search a phone number and fetch the information.Delete a phone number and related information.We can think of using the following data structures to maintain information about different phone numbers.Array of phone numbers and records.Linked List of phone numbers and records.Balanced binary search tree with phone numbers as keys.Direct Access Table.Forarrays and linked lists, we need to search in a linear fashion, which can be costly in practice. If we use arrays and keep the data sorted, then a phone number can be searched in O(Logn) time using Binary Search, but insert and delete operations become costly as we have to maintain sorted order.Withbalanced binary search tree, we get moderate search, insert and delete times. All of these operations can be guaranteed to be in O(Logn) time.Another solution that one can think of is to use adirect access tablewhere we make a big array and use phone numbers as index in the array. An entry in array is NIL if phone number is not present, else the array entry stores pointer to records corresponding to phone number. Time complexity wise this solution is the best among all, we can do all operations in O(1) time. For example to insert a phone number, we create a record with details of given phone number, use phone number as index and store the pointer to the created record in table.This solution has many practical limitations. First problem with this solution is extra space required is huge. For example if phone number is n digits, we need O(m * 10n) space for table where m is size of a pointer to record. Another problem is an integer in a programming language may not store n digits.Due to above limitations Direct Access Table cannot always be used.Hashingis the solution that can be used in almost all such situations and performs extremely well compared to above data structures like Array, Linked List, Balanced BST in practice. With hashing we get O(1) search time on average (under reasonable assumptions) and O(n) in worst case.Hashing is an improvement over Direct Access Table. The idea is to use hash function that converts a given phone number or any other key to a smaller number and uses the small number as index in a table called hash table.Hash Function:A function that converts a given big phone number to a small practical integer value. The mapped integer value is used as an index in hash table. In simple terms, a hash function maps a big number or string to a small integer that can be used as index in hash table.A good hash function should have following properties1) Efficiently computable.2) Should uniformly distribute the keys (Each table position equally likely for each key)For example for phone numbers a bad hash function is to take first three igits. A better function is consider last three digits. Please note that this may not be the best hash function. There may be better ways.Hash Table:An array that stores pointers to records corresponding to a given phone number. An entry in hash table is NIL if no existing phone number has hash function value equal to the index for the entry.Collision Handling: Since a hash function gets us a small number for a key which is a big integer or string, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique. Following are the ways to handle collisions:Chaining:The idea is to make each cell of hash table point to a linked list of records that have same hash function value. Chaining is simple, but requires additional memory outside the table.Open Addressing:In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we one by one examine table slots until the desired element is found or it is clear that the element is not in the table.Next Posts:Separate Chaining for Collision HandlingOpen Addressing for Collision HandlingReferences:MIT Video LectureIITD Video Lecture“Introduction to Algorithms”, Second Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein.http://www.cs.princeton.edu/~rs/AlgsDS07/10Hashing.pdfhttp://www.martinbroadhurst.com/articles/hash-table.htmlPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Hashing | Set 2 (Separate Chaining).entry-headerWe strongly recommend to refer below post as a prerequisite of this.http://geeksquiz.com/hashing-set-1-introduction/What is Collision?Since a hash function gets us a small number for a key which is a big integer or string, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique.What are the chances of collisions with large table?Collisions are very likely even if we have big table to store keys. An important observation isBirthday Paradox. With only 23 persons, the probability that two people have same birthday is 50%.How to handle Collisions?There are mainly two methods to handle collision:1) Separate Chaining2) Open AddressingIn this article, only separate chaining is discussed. We will be discussing Open addressing in next post.Separate Chaining:The idea is to make each cell of hash table point to a linked list of records that have same hash function value.Let us consider a simple hash function as &#8220;key mod 7&#8221; and sequence of keys as 50, 700, 76, 85, 92, 73, 101.Advantages:1) Simple to implement.2) Hash table never fills up, we can always add more elements to chain.3) Less sensitive to the hash function or load factors.4) It is mostly used when it is unknown how many and how frequently keys may be inserted or deleted.Disadvantages:1) Cache performance of chaining is not good as keys are stored using linked list.  Open addressing provides better cache performance as everything is stored in same table.2) Wastage of Space (Some Parts of hash table are never used)3) If the chain becomes long, then search time can become O(n) in worst case.4) Uses extra space for links.Performance of Chaining:Performance of hashing can be evaluated under the assumption that each key is equally likely to be hashed to any slot of table (simple uniform hashing).m = Number of slots in hash table
 n = Number of keys to be inserted in has table
 
 Load factor &alpha; = n/m 
  
 Expected time to search = O(1 + &alpha;)
 
 Expected time to insert/delete = O(1 + &alpha;)

 Time complexity of search insert and delete is 
 O(1) if  &alpha; is O(1)Next Post:Open Addressing for Collision HandlingReferences:http://courses.csail.mit.edu/6.006/fall09/lecture_notes/lecture05.pdfPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveHashing | Set 3 (Open Addressing).entry-headerWe strongly recommend to refer below post as a prerequisite of this.Hashing | Set 1 (Introduction)Hashing | Set 2 (Separate Chaining)Open AddressingLike separate chaining, open addressing is a method for handling collisions. In Open Addressing, all elements are stored in the hash table itself. So at any point, size of table must be greater than or equal to total number of keys (Note that we can increase table size by copying old data if needed).Insert(k): Keep probing until an empty slot is found. Once an empty slot is found, insert k.Search(k): Keep probing until slot&#8217;s key doesn&#8217;t become equal to k or an empty slot is reached.Delete(k):Delete operation is interesting. If we simply delete a key, then search may fail. So slots of deleted keys are marked specially as &#8220;deleted&#8221;.Insert can insert an item in a deleted slot, but search doesn&#8217;t stop at a deleted slot.Open Addressing is done following ways:a) Linear Probing:In linear probing, we linearly probe for next slot. For example, typical gap between two probes is 1 as taken in below example also.lethash(x)be the slot index computed using hash function andSbe the table sizeIf slot hash(x) % S is full, then we try (hash(x) + 1) % S
If (hash(x) + 1) % S is also full, then we try (hash(x) + 2) % S
If (hash(x) + 2) % S is also full, then we try (hash(x) + 3) % S 
..................................................
..................................................Let us consider a simple hash function as “key mod 7” and sequence of keys as 50, 700, 76, 85, 93, 73, 101.Clustering:The main problem with linear probing is clustering, many consecutive elements form groups and it starts taking time to find a free slot or to search an element.b) Quadratic ProbingWe look for i2&#8216;th slot in i&#8217;th iteration.let hash(x) be the slot index computed using hash function.  
If slot hash(x) % S is full, then we try (hash(x) + 1*1) % S
If (hash(x) + 1*1) % S is also full, then we try (hash(x) + 2*2) % S
If (hash(x) + 2*2) % S is also full, then we try (hash(x) + 3*3) % S
..................................................
..................................................c) Double HashingWe use another hash function hash2(x) and look for i*hash2(x) slot in i&#8217;th rotation.let hash(x) be the slot index computed using hash function.  
If slot hash(x) % S is full, then we try (hash(x) + 1*hash2(x)) % S
If (hash(x) + 1*hash2(x)) % S is also full, then we try (hash(x) + 2*hash2(x)) % S
If (hash(x) + 2*hash2(x)) % S is also full, then we try (hash(x) + 3*hash2(x)) % S
..................................................
..................................................Seethisfor step by step diagrams.Comparison of above three:Linear probing has the best cache performance, but suffers from clustering. One more advantage of Linear probing is easy to compute.Quadratic probing lies between the two in terms of cache performance and clustering.Double hashing has poor cache performance but no clustering. Double hashing requires more computation time as two hash functions need to be computed.Open Addressing vs. Separate ChainingAdvantages of Chaining:1) Chaining is Simpler to implement.2) In chaining, Hash table never fills up, we can always add more elements to chain. In open addressing, table may become full.3) Chaining is Less sensitive to the hash function or load factors.4) Chaining is mostly used when it is unknown how many and how frequently keys may be inserted or deleted.5) Open addressing requires extra care for to avoid clustering and load factor.Advantages of Open Addressing1) Cache performance of chaining is not good as keys are stored using linked list. Open addressing provides better cache performance as everything is stored in same table.2) Wastage of Space (Some Parts of hash table in chaining are never used).  In Open addressing, a slot can be used even if an input doesn&#8217;t map to it.3) Chaining uses extra space for links.Performance of Open Addressing:Like Chaining, performance of hashing can be evaluated under the assumption that each key is equally likely to be hashed to any slot of table (simple uniform hashing)m = Number of slots in hash table
 n = Number of keys to be inserted in has table
 
 Load factor α = n/m  ( < 1 )

 Expected time to search/insert/delete < 1/(1-&Alpha;) 

 So Search, Insert and Delete take O(1/(1+&Aplha;)) timeReferences:http://courses.csail.mit.edu/6.006/fall11/lectures/lecture10.pdfhttps://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu6.pdfPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.Check if a given graph is tree or not.entry-headerWrite a function that returns true if a given undirected graph is tree and false otherwise.  For example, the following graph is a tree.But the following graph is not a tree.An undirected graph is tree if it has following properties.1) There is no cycle.2) The graph is connected.For an undirected graph we can either useBFSorDFSto detect above two properties.How to detect cycle in an undirected graph?We can either use BFS or DFS. For every visited vertex ‘v’, if there is an adjacent ‘u’ such that u is already visited and u is not parent of v, then there is a cycle in graph. If we don’t find such an adjacent for any vertex, we say that there is no cycle (SeeDetect cycle in an undirected graphfor more details).How to check for connectivity?Since the graph is undirected, we can start BFS or DFS from any vertex and check if all vertices are reachable or not.  If all vertices are reachable, then graph is connected, otherwise not.C++// A C++ Program to check whether a graph is tree or not
#include&lt;iostream&gt;
#include &lt;list&gt;
#include &lt;limits.h&gt;
using namespace std;

// Class for an undirected graph
class Graph
{
    int V;    // No. of vertices
    list&lt;int&gt; *adj; // Pointer to an array for adjacency lists
    bool isCyclicUtil(int v, bool visited[], int parent);
public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w);   // to add an edge to graph
    bool isTree();   // returns true if graph is tree
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
    adj[w].push_back(v); // Add v to w’s list.
}

// A recursive function that uses visited[] and parent to
// detect cycle in subgraph reachable from vertex v.
bool Graph::isCyclicUtil(int v, bool visited[], int parent)
{
    // Mark the current node as visited
    visited[v] = true;

    // Recur for all the vertices adjacent to this vertex
    list&lt;int&gt;::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
    {
        // If an adjacent is not visited, then recur for 
        // that adjacent
        if (!visited[*i])
        {
           if (isCyclicUtil(*i, visited, v))
              return true;
        }

        // If an adjacent is visited and not parent of current
        // vertex, then there is a cycle.
        else if (*i != parent)
           return true;
    }
    return false;
}

// Returns true if the graph is a tree, else false.
bool Graph::isTree()
{
    // Mark all the vertices as not visited and not part of 
    // recursion stack
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    // The call to isCyclicUtil serves multiple purposes.
    // It returns true if graph reachable from vertex 0 
    // is cyclcic. It also marks all vertices reachable 
    // from 0.
    if (isCyclicUtil(0, visited, -1))
             return false;

    // If we find a vertex which is not reachable from 0 
    // (not marked by isCyclicUtil(), then we return false
    for (int u = 0; u &lt; V; u++)
        if (!visited[u])
           return false;

    return true;
}

// Driver program to test above functions
int main()
{
    Graph g1(5);
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    g1.isTree()? cout &lt;&lt; &quot;Graph is Tree\n&quot;:
                 cout &lt;&lt; &quot;Graph is not Tree\n&quot;;

    Graph g2(5);
    g2.addEdge(1, 0);
    g2.addEdge(0, 2);
    g2.addEdge(2, 1);
    g2.addEdge(0, 3);
    g2.addEdge(3, 4);
    g2.isTree()? cout &lt;&lt; &quot;Graph is Tree\n&quot;:
                 cout &lt;&lt; &quot;Graph is not Tree\n&quot;;

    return 0;
}Java// A Java Program to check whether a graph is tree or not
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency
// list representation
class Graph
{
    private int V;   // No. of vertices
    private LinkedList&lt;Integer&gt; adj[]; //Adjacency List

    // Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i&lt;v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v,int w)
    {
        adj[v].add(w);
        adj[w].add(v);
    }

    // A recursive function that uses visited[] and parent
    // to detect cycle in subgraph reachable from vertex v.
    Boolean isCyclicUtil(int v, Boolean visited[], int parent)
    {
        // Mark the current node as visited
        visited[v] = true;
        Integer i;

        // Recur for all the vertices adjacent to this vertex
        Iterator&lt;Integer&gt; it = adj[v].iterator();
        while (it.hasNext())
        {
            i = it.next();

            // If an adjacent is not visited, then recur for
            // that adjacent
            if (!visited[i])
            {
                if (isCyclicUtil(i, visited, v))
                    return true;
            }

            // If an adjacent is visited and not parent of 
            // current vertex, then there is a cycle.
            else if (i != parent)
               return true;
        }
        return false;
    }

    // Returns true if the graph is a tree, else false.
    Boolean isTree()
    {
        // Mark all the vertices as not visited and not part
        // of recursion stack
        Boolean visited[] = new Boolean[V];
        for (int i = 0; i &lt; V; i++)
            visited[i] = false;

        // The call to isCyclicUtil serves multiple purposes
        // It returns true if graph reachable from vertex 0
        // is cyclcic. It also marks all vertices reachable
        // from 0.
        if (isCyclicUtil(0, visited, -1))
            return false;

        // If we find a vertex which is not reachable from 0
        // (not marked by isCyclicUtil(), then we return false
        for (int u = 0; u &lt; V; u++)
            if (!visited[u])
                return false;

        return true;
    }

    // Driver method
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        Graph g1 = new Graph(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        if (g1.isTree())
            System.out.println(&quot;Graph is Tree&quot;);
        else
            System.out.println(&quot;Graph is not Tree&quot;);

        Graph g2 = new Graph(5);
        g2.addEdge(1, 0);
        g2.addEdge(0, 2);
        g2.addEdge(2, 1);
        g2.addEdge(0, 3);
        g2.addEdge(3, 4);

        if (g2.isTree())
            System.out.println(&quot;Graph is Tree&quot;);
        else
            System.out.println(&quot;Graph is not Tree&quot;);

    }
}
// This code is contributed by Aakash HasijaOutput:Graph is Tree
Graph is not TreeThanks toVinit Vermafor suggesting this problem and initial solution. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveAVL with duplicate keys.entry-headerPlease refer below post before reading about AVL tree handling of duplicates.How to handle duplicates in Binary Search Tree?The is to augmentAVL treenode to store count together with regular fields like key, left and right pointers.Insertion of keys 12, 10, 20, 9, 11, 10, 12, 12 in an empty Binary Search Tree would create following.12(3)
       /        \
     10(2)      20(1)
    /    \       
 9(1)   11(1)Count of a key is shown in bracketBelow is C implementation of normal AVL Tree with count with every key. This code basically is taken fromcode for insert and delete in AVL tree. The changes made for handling duplicates are highlighted, rest of the code is same.The important thing to note is changes are very similar to simple Binary Search Tree changes.// AVL tree that handles duplicates
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct node
{
    int key;
    struct node *left;
    struct node *right;
    int height;
    int count;
};

// A utility function to get maximum of two integers
int max(int a, int b);

// A utility function to get height of the tree
int height(struct node *N)
{
    if (N == NULL)
        return 0;
    return N-&gt;height;
}

// A utility function to get maximum of two integers
int max(int a, int b)
{
    return (a &gt; b)? a : b;
}

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct node* newNode(int key)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;key   = key;
    node-&gt;left   = NULL;
    node-&gt;right  = NULL;
    node-&gt;height = 1;  // new node is initially added at leaf
    node-&gt;count = 1;
    return(node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct node *rightRotate(struct node *y)
{
    struct node *x = y-&gt;left;
    struct node *T2 = x-&gt;right;

    // Perform rotation
    x-&gt;right = y;
    y-&gt;left = T2;

    // Update heights
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;

    // Return new root
    return x;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct node *leftRotate(struct node *x)
{
    struct node *y = x-&gt;right;
    struct node *T2 = y-&gt;left;

    // Perform rotation
    y-&gt;left = x;
    x-&gt;right = T2;

    //  Update heights
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;

    // Return new root
    return y;
}

// Get Balance factor of node N
int getBalance(struct node *N)
{
    if (N == NULL)
        return 0;
    return height(N-&gt;left) - height(N-&gt;right);
}

struct node* insert(struct node* node, int key)
{
    /* 1.  Perform the normal BST rotation */
    if (node == NULL)
        return (newNode(key));

    // If key already exists in BST, icnrement count and return
    if (key == node-&gt;key)
    {
        (node-&gt;count)++;
        return node;
    }

     /* Otherwise, recur down the tree */
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else
        node-&gt;right = insert(node-&gt;right, key);

    /* 2. Update height of this ancestor node */
    node-&gt;height = max(height(node-&gt;left), height(node-&gt;right)) + 1;

    /* 3. Get the balance factor of this ancestor node to check whether
       this node became unbalanced */
    int balance = getBalance(node);

    // If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)
        return rightRotate(node);

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)
        return leftRotate(node);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key)
    {
        node-&gt;left =  leftRotate(node-&gt;left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key)
    {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    /* return the (unchanged) node pointer */
    return node;
}

/* Given a non-empty binary search tree, return the node with minimum
   key value found in that tree. Note that the entire tree does not
   need to be searched. */
struct node * minValueNode(struct node* node)
{
    struct node* current = node;

    /* loop down to find the leftmost leaf */
    while (current-&gt;left != NULL)
        current = current-&gt;left;

    return current;
}

struct node* deleteNode(struct node* root, int key)
{
    // STEP 1: PERFORM STANDARD BST DELETE

    if (root == NULL)
        return root;

    // If the key to be deleted is smaller than the root's key,
    // then it lies in left subtree
    if ( key &lt; root-&gt;key )
        root-&gt;left = deleteNode(root-&gt;left, key);

    // If the key to be deleted is greater than the root's key,
    // then it lies in right subtree
    else if( key &gt; root-&gt;key )
        root-&gt;right = deleteNode(root-&gt;right, key);

    // if key is same as root's key, then This is the node
    // to be deleted
    else
    {
        // If key is present more than once, simply decrement
        // count and return
        if (root-&gt;count &gt; 1)
        {
            (root-&gt;count)--;
            return;
        }
        // ElSE, delete the node

        // node with only one child or no child
        if( (root-&gt;left == NULL) || (root-&gt;right == NULL) )
        {
            struct node *temp = root-&gt;left ? root-&gt;left : root-&gt;right;

            // No child case
            if(temp == NULL)
            {
                temp = root;
                root = NULL;
            }
            else // One child case
             *root = *temp; // Copy the contents of the non-empty child

            free(temp);
        }
        else
        {
            // node with two children: Get the inorder successor (smallest
            // in the right subtree)
            struct node* temp = minValueNode(root-&gt;right);

            // Copy the inorder successor's data to this node
            root-&gt;key = temp-&gt;key;

            // Delete the inorder successor
            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);
        }
    }

    // If the tree had only one node then return
    if (root == NULL)
      return root;

    // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE
    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + 1;

    // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to check whether
    //  this node became unbalanced)
    int balance = getBalance(root);

    // If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &gt;= 0)
        return rightRotate(root);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &lt; 0)
    {
        root-&gt;left =  leftRotate(root-&gt;left);
        return rightRotate(root);
    }

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &lt;= 0)
        return leftRotate(root);

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &gt; 0)
    {
        root-&gt;right = rightRotate(root-&gt;right);
        return leftRotate(root);
    }

    return root;
}

// A utility function to print preorder traversal of the tree.
// The function also prints height of every node
void preOrder(struct node *root)
{
    if(root != NULL)
    {
        printf(&quot;%d(%d) &quot;, root-&gt;key, root-&gt;count);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
  struct node *root = NULL;

  /* Constructing tree given in the above figure */
    root = insert(root, 9);
    root = insert(root, 5);
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 9);
    root = insert(root, 7);
    root = insert(root, 17);

    printf(&quot;Pre order traversal of the constructed AVL tree is \n&quot;);
    preOrder(root);

    root = deleteNode(root, 9);

    printf(&quot;\nPre order traversal after deletion of 10 \n&quot;);
    preOrder(root);

    return 0;
}Output:Pre order traversal of the constructed AVL tree is
9(2) 5(2) 7(1) 10(1) 17(1)
Pre order traversal after deletion of 10
9(1) 5(2) 7(1) 10(1) 17(1)Thanks toRounaq Jhunjhunu Walafor sharing initial code. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveC Program for Red Black Tree Insertion.entry-headerWe strongly recommend to go through following articles as a prerequisite for this.Red-Black Tree IntroductionRed Black Tree InsertionFollowing is the complete algorithm discussed inRed Black Tree Insertionarticle.Color of a NULL node is considered as BLACK.Let x be the newly inserted node.1)Perform standard BST insertion and make the color of newly inserted nodes as RED.2)Do following if color of x’s parent is not BLACK or x is not root.….a)If x’s uncle is RED(Grand parent must have been black from property 4)……..(i) Change color of parent and uncle as BLACK.……..(ii) color of grand parent as RED.……..(iii) Change x = x’s grandparent, repeat steps 2 and 3 for new x.….b)If x’s uncle is BLACK, then there can be four configurations for x, x’s parent (p) and x’sgrandparent (g).……..i) Left Left Case (p is left child of g and x is left child of p)……..ii) Left Right Case (p is left child of g and x is right child of p)……..iii) Right Right Case (Mirror of case a)……..iv) Right Left Case (Mirror of case c)3)If x is root, change color of x as BLACK (Black height of complete tree increases by 1).In this article, C code for insertion is discussed.  Following is complete C code for insertion. Following are few important points for coding the insertion process.1) Since we need to access uncle node to decide case, it is a good idea to have parent pointer in every node.2) We also need to write functions for left and right rotations. These functions are similar to left and right rotations for AVL Tree insertion.   In AVL Tree, we maintain height, but here we need to maintain parent pointer and color.The  following code strictly follows the steps given inCLRS book.// C program for Red-Black Tree insertion
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

//A Red-Black tree node structure
struct node
{
    int data;     // for data part
    char color;  // for color property

    //links for left, right children and parent
    struct node *left, *right, *parent;
};


// Left Rotation
void LeftRotate(struct node **root,struct node *x)
{
    //y stored pointer of right child of x
    struct node *y = x-&gt;right;

    //store y's left subtree's pointer as x's right child
    x-&gt;right = y-&gt;left;

    //update parent pointer of x's right
    if (x-&gt;right != NULL)
        x-&gt;right-&gt;parent = x;

    //update y's parent pointer
    y-&gt;parent = x-&gt;parent;

    // if x's parent is null make y as root of tree
    if (x-&gt;parent == NULL)
        (*root) = y;

    // store y at the place of x
    else if (x == x-&gt;parent-&gt;left)
        x-&gt;parent-&gt;left = y;
    else    x-&gt;parent-&gt;right = y;

    // make x as left child of y
    y-&gt;left = x;

    //update parent pointer of x
    x-&gt;parent = y;
}


// Right Rotation (Similar to LeftRotate)
void rightRotate(struct node **root,struct node *y)
{
    struct node *x = y-&gt;left;
    y-&gt;left = x-&gt;right;
    if (x-&gt;right != NULL)
        x-&gt;right-&gt;parent = y;
    x-&gt;parent =y-&gt;parent;
    if (x-&gt;parent == NULL)
        (*root) = x;
    else if (y == y-&gt;parent-&gt;left)
        y-&gt;parent-&gt;left = x;
    else y-&gt;parent-&gt;right = x;
    x-&gt;right = y;
    y-&gt;parent = x;
}

// Utility function to fixup the Red-Black tree after standard BST insertion
void insertFixUp(struct node **root,struct node *z)
{
    // iterate until z is not the root and z's parent color is red
    while (z != *root &amp;&amp; z-&gt;parent-&gt;color == 'R')
    {
        struct node *y;

        // Find uncle and store uncle in y
        if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)
            y = z-&gt;parent-&gt;parent-&gt;right;
        else
            y = z-&gt;parent-&gt;parent-&gt;left;

        // If uncle is RED, do following
        // (i)  Change color of parent and uncle as BLACK
        // (ii) Change color of grandparent as RED
        // (iii) Move z to grandparent
        if (y-&gt;color == 'R')
        {
            y-&gt;color = 'B';
            z-&gt;parent-&gt;color = 'B';
            z-&gt;parent-&gt;parent-&gt;color = 'R';
            z = z-&gt;parent-&gt;parent;
        }

        // Uncle is BLACK, there are four cases (LL, LR, RL and RR)
        else
        {
            // Left-Left (LL) case, do following
            // (i)  Swap color of parent and grandparent
            // (ii) Right Rotate Grandparent
            if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left &amp;&amp;
                z == z-&gt;parent-&gt;left)
            {
                char ch = z-&gt;parent-&gt;color ;
                z-&gt;parent-&gt;color = z-&gt;parent-&gt;parent-&gt;color;
                z-&gt;parent-&gt;parent-&gt;color = ch;
                rightRotate(root,z-&gt;parent-&gt;parent);
            }

            // Left-Right (LR) case, do following
            // (i)  Swap color of current node  and grandparent
            // (ii) Left Rotate Parent
            // (iii) Right Rotate Grand Parent
            if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left &amp;&amp;
                z == z-&gt;parent-&gt;right)
            {
                char ch = z-&gt;color ;
                z-&gt;color = z-&gt;parent-&gt;parent-&gt;color;
                z-&gt;parent-&gt;parent-&gt;color = ch;
                LeftRotate(root,z-&gt;parent);
                rightRotate(root,z-&gt;parent-&gt;parent);
            }

            // Right-Right (RR) case, do following
            // (i)  Swap color of parent and grandparent
            // (ii) Left Rotate Grandparent
            if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;right &amp;&amp;
                z == z-&gt;parent-&gt;right)
            {
                char ch = z-&gt;parent-&gt;color ;
                z-&gt;parent-&gt;color = z-&gt;parent-&gt;parent-&gt;color;
                z-&gt;parent-&gt;parent-&gt;color = ch;
                LeftRotate(root,z-&gt;parent-&gt;parent);
            }

            // Right-Left (RL) case, do following
            // (i)  Swap color of current node  and grandparent
            // (ii) Right Rotate Parent
            // (iii) Left Rotate Grand Parent
            if (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;right &amp;&amp;
                z == z-&gt;parent-&gt;left)
            {
                char ch = z-&gt;color ;
                z-&gt;color = z-&gt;parent-&gt;parent-&gt;color;
                z-&gt;parent-&gt;parent-&gt;color = ch;
                rightRotate(root,z-&gt;parent);
                LeftRotate(root,z-&gt;parent-&gt;parent);
            }
        }
    }
    (*root)-&gt;color = 'B'; //keep root always black
}

// Utility function to insert newly node in RedBlack tree
void insert(struct node **root, int data)
{
    // Allocate memory for new node
    struct node *z = (struct node*)malloc(sizeof(struct node));
    z-&gt;data = data;
    z-&gt;left = z-&gt;right = z-&gt;parent = NULL;

     //if root is null make z as root
    if (*root == NULL)
    {
        z-&gt;color = 'B';
        (*root) = z;
    }
    else
    {
        struct node *y = NULL;
        struct node *x = (*root);

        // Follow standard BST insert steps to first insert the node
        while (x != NULL)
        {
            y = x;
            if (z-&gt;data &lt; x-&gt;data)
                x = x-&gt;left;
            else
                x = x-&gt;right;
        }
        z-&gt;parent = y;
        if (z-&gt;data &gt; y-&gt;data)
            y-&gt;right = z;
        else
            y-&gt;left = z;
        z-&gt;color = 'R';

        // call insertFixUp