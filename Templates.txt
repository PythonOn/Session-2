Covering the nitty-gritties of C++ templates.; Author: Ajay Vijayvargiya; Updated: 16 Jan 2013; Section: C / C++ Language; Chapter: Languages; Updated: 16 Jan 2013" />//<![CDATA[
function defrm () { /* thanks twitter */ document.write = ''; window.top.location = window.self.location;  setTimeout(function() { document.body.innerHTML = ''; }, 0);  window.self.onload = function(evt) { document.body.innerHTML = ''; }; }if (window.top !== window.self) {  try {  if (window.top.location.host) { /* will throw */ } else { defrm(); /* chrome */ }  } catch (ex) { defrm(); /* everyone else */ } }if (typeof(DemoUrl)!='undefined')   document.write(unescape('%3Cme')+'ta http'+'-equiv="re'+'fresh"                  con'+'tent="1;url='+DemoUrl+unescape('"%3CE'));
(function() { 
	var _dma = document.createElement('script');
        _dma.type = 'text/javascript';
        _dma.async = true;
        _dma.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'cdn2.developermedia.com/a.min.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(_dma);
})();

//]]>var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-1735123-1']);
	_gaq.push(['_trackPageview']);
	_gaq.push(['_setDomainName', 'www.codeproject.com']);
	_gaq.push(['_setSessionTimeout', '1200']); 

	(function () {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
	})();11,946,630 members (52,462 online)//<!--
			function doSubmit(secure)
			{
				if (secure)
					document.subForm.action = "https://www.codeproject.com/script/Membership/LogOn.aspx?rp=%2fArticles%2f257589%2fAn-Idiots-Guide-to-Cplusplus-Templates-Part"
				else
					document.subForm.action = "https://www.codeproject.com/script/Membership/LogOn.aspx?rp=%2fArticles%2f257589%2fAn-Idiots-Guide-to-Cplusplus-Templates-Part"
				document.subForm.submit();
				return true;
			}//-->Sign inEmailPasswordfunction Join(){
 var url = 'http://www.codeproject.com/script/Membership/Modify.aspx?meml=' + document.subForm.Email.value;
 document.location.href=url;return false;
}
document.write('<input type="button" class="create" onclick="return Join();" value="Join"');
document.write('<input type="hidden" name="fld_quicksign" value="true"  />');&nbsp;Forgot your password?Sign in usingSearch within:ArticlesQuick AnswersMessageshomearticlesChapters and Sections&gt;SearchLatest ArticlesLatest Tips/TricksTop ArticlesBeginner ArticlesTechnical BlogsPosting/Update GuidelinesArticle Help ForumArticle CompetitionSubmit an article or tipPost your Blogquick answersQ&amp;AAsk a Question about this 
			articleAsk a QuestionView Unanswered QuestionsView All Questions...Linux questionsC# questionsASP.NET questionsSQL questionsVB.NET questionsdiscussionsforumsAll Message Boards...Application Lifecycle&gt;Running a BusinessSales / MarketingCollaboration / Beta TestingWork  IssuesDesign and ArchitectureASP.NETJavaScriptC / C++ / MFC&gt;ATL /  WTL / STLManaged C++/CLIC#Free ToolsObjective-C and SwiftDatabaseHardware &amp; Devices&gt;System AdminHosting and ServersJava.NET FrameworkAndroidiOSMobileSharePointSilverlight / WPFVisual BasicWeb DevelopmentSite Bugs / SuggestionsSpam and Abuse WatchfeaturesCompetitionsNewsThe Insider NewsletterThe Daily Build NewsletterNewsletter archiveSurveysProduct ShowcaseResearch LibraryCodeProject StuffcommunityloungeWho's WhoMost Valuable ProfessionalsThe LoungeThe Insider NewsThe Weird & The WonderfulThe SoapboxPress ReleasesNon-English Language&gt;General Indian TopicsGeneral Chinese TopicshelpWhat is 'CodeProject'?General FAQAsk a QuestionBugs and SuggestionsArticle Help ForumSite MapAdvertise with usEmployment OpportunitiesAbout UsArticles&#187;Languages&#187;C / C++ Language&#187;Templates&nbsp;ArticleAlternativesComments(123)Add your ownalternative versionTagged asC++VC9.0VC10.0C++11VC8.0LinuxWindowsGCCDevTemplatesStats619.3K views356 bookmarkedPosted7 Oct 2011An Idiot&#39;s Guide to C++ Templates - Part 1Ajay Vijayvargiya,16 Jan 2013CPOL&nbsp;&nbsp;4.88(159votes)123454.88/5 - 159 votes6 removedμ 4.80, σa0.96 [?]Rate this:PleaseSign up or sign into vote.Covering the nitty-gritties of C++ templates.ProlusionMost C++ programmers stay away from C++ templates due to their perplexed nature. The excuses against templates:Hard to learn and adapt.Compiler errors are vague, and very long.Not worth the effort.Admitted that templates are slightly hard to learn, understand, and adapt. Nevertheless, the advantages we gain from using templates would outweigh the negatives. There is 
a lot more than generic functions or classes that can be wrapped around templates. I would explicate them.While C++ templates and STL (Standard Template Library) are siblings, technically. In this article, I would only cover templates at the core level. Next parts of this series would cover more advanced and interesting stuff around templates, and some know-how about STL.Table of ContentsThe Syntax DramaFunction TemplatesPointers, References and Arrays with TemplatesMultiple Types with Function TemplatesFunction Template - Template FunctionExplicit Template Argument SpecificationDefault Arguments with Function TemplatesClass TemplatesMultiple Types with Class TemplatesNon-type Template ArgumentsTemplate Class as Argument to Class TemplateDefault Template Arguments with Class TemplatesClass' Methods as Function TemplatesAt The EndThe Syntax DramaAs you probably know, template largely uses the angle brackets: The less than (&lt;) and the greater than (&gt;) operators. For templates, they are always used together in this form:&lt; Content &gt;WhereContentcan be:class T/typename TA data type, which maps toTAn integral specificationAn integral constant/pointer/reference which maps to specification mentioned above.For point 1 and 2, the symbolTis nothing but some data-type, which can be any data-type - a basic datatype (int,doubleetc), or a UDT.Let's jump to an example. Suppose you write a function that prints double (twice) of a number:voidPrintTwice(intdata)
{
    cout &lt;&lt;"Twice is: "&lt;&lt; data *2&lt;&lt; endl;         
}Which can be called passing anint:PrintTwice(120);//240Now, if you want to print double of adouble, you would overload this function as:voidPrintTwice(doubledata)
{
    cout &lt;&lt;"Twice is: "&lt;&lt; data *2&lt;&lt; endl;         
}Interestingly, class typeostream(thetypeofcoutobject) has multiple overloads foroperator &lt;&lt;- for all basic data-types. Therefore, same/similar code works for bothintanddouble, and no change is required for ourPrintTwiceoverloads - yes, we justcopy-pastedit. Had we used one ofprintf-functions, the two overloads would look like:voidPrintTwice(intdata)
{
    printf("Twice is:%d", data *2);
}voidPrintTwice(doubledata)
{
    printf("Twice is:%lf", data *2);
}Here the point is not aboutcoutorprintto display on console, but about the code - which isabsolutely same. This isoneof the many situations where we can utilize the groovy feature provided by the C++ language: Templates!Templates are of two types:Function TemplatesClass TemplatesC++ templates is a programming model that allowsplugging-inof any data-type to the code (templated code). Without template, you would need to replicate same code all over again and again, for all required data-types. And obviously, as said before, it requires code maintenance.Anyway, here is thesimplifiedPrintTwice, utilizing templates:voidPrintTwice(TYPEdata)
{
    cout&lt;&lt;"Twice: "&lt;&lt; data *2&lt;&lt; endl;
}Here, actualtypeofTYPEwould be deduced (determined) by the compiler depending on argument passed to the function. IfPrintTwiceis called asPrintTwice(144);it would be anint, if you pass3.14to this function,TYPEwould be deduced asdoubletype.You might be confused whatTYPEis, how the compiler is going to determine that this is a function template. IsTYPEtype defined usingtypedefkeyword somewhere?No, my boy! Here we use the keywordtemplateto let compiler know that we are defining a function template.Function TemplatesHere is thetemplatedfunctionPrintTwice:template&lt;class TYPE&gt;voidPrintTwice(TYPE data)
{
    cout&lt;&lt;"Twice: "&lt;&lt; data *2&lt;&lt; endl;
}The first line of code:template&lt;class TYPE&gt;tells the compiler that this is afunction-template.The actual meaning ofTYPEwould be deduced by compiler depending on the argument passed to this function. Here, the name,TYPEis known astemplate type parameter.For instance, if we call the function as:PrintTwice(124);TYPEwould be replaced by compiler asint, and compiler wouldinstantiatethis template-function as:voidPrintTwice(intdata)
{
    cout&lt;&lt;"Twice: "&lt;&lt; data *2&lt;&lt; endl;
}And, if we call this function as:PrintTwice(4.5547);It would instantiate another function as:voidPrintTwice(doubledata)
{
    cout&lt;&lt;"Twice: "&lt;&lt; data *2&lt;&lt; endl;
}It means, in your program, if you callPrintTwicefunction withintanddoubleparameter types,twoinstances of this function would be generated by compiler:voidPrintTwice(intdata) { ... }voidPrintTwice(doubledata) { ... }Yes, the code is duplicated. But these two overloads are instantiated by the compiler and not by the programmer. The true benefit is that you need not to docopy-pastingthe same code, or to manually maintain the code for different data-types, or to write up a new overload for new data-type that arrives later. You would just provide atemplateof a function, and rest would be managed by compiler.It is also true that code size would increase, since there are now two function definitions. The code-size (at binary/assembly level) would almost be same. Effectively, forNnumber of data-types,Ninstances of same function (i.e. overloaded functions) would be created. There are advanced compiler/linker level optimizations which can somewhat reduce the code size, if instantiated functions are same, or some part of function body is same. I wouldn't discuss it now.But, on a positive side, when you manually defineNdifferent overloads (sayN=10), thoseNdifferent overloads would be anyway be compiled,linked and packed in binary (the executable). However, with templates,onlythe required instantiations of function would get into final executable. With templates, the overloaded copies of function might be less than N, and it can be more than N - but exactly the number of required copies - no more no less!Also, for non-templated implementations, the compiler has to compile all those N copies - since they are in your source-code! When you attachtemplatewith a generic function, compiler would compile only for required set of data-types. It basically means the compilation would be faster if number of different data-types is less thanN!It would be a perfectly valid argument, that the compiler/linker would likely do all possible optimizations to remove unused non-template function' implementations from the final image. But, again, do understand that compiler has tocompileall those overloads (for syntax checking etc). With templates, the compilation would happen only for required data-types - you can call it as &quot;On demand compilation&quot;.Enough of text-only content for now! You can come back and re-read it again. Let's move ahead.Now, let's write another function template that would return the twice of given number:template&lt;typenameTYPE&gt;
TYPE Twice(TYPE data)
{returndata *2;
}You should have noticed that I usedtypename, instead ofclass. No, it is not required to usetypenamekeyword if a function returning something. For template programming, these two keywords are very much the same. There is a historical reason for having two keywords for same purpose, and I hate history.However, there are instances where you canonlyuse the newer keyword -typename. (When a particular type is defined in another type, and is dependent on some template parameter - Let this discussion be deferred to another part).Moving ahead. When we call this function as:cout &lt;&lt; Twice(10);
cout &lt;&lt; Twice(3.14);
cout &lt;&lt; Twice(Twice(55));Following set of functions would be generated:intTwice(intdata) {..}doubleTwice(doubledata) {..}Two things:In third line of code snipped above,Twiceis calledtwice -the return value/type of first call would be the argument/type of second call. Hence, both calls are ofinttype (Since argument typeTYPE, and return type are same).If a template function is instantiated for a particular data-type, compiler would re-use the same function' instance - if the function is invoked again for same data-type. It means, irrespective of where, in your code, you invoke the function template with same type - in same function, in different function, or anywhere in another source file (of same project/build).Let's write up a function template that would return the addition of two numbers:template&lt;class T&gt;
T Add(T n1, T n2)
{returnn1 + n2;
}Firstly, I just replaced template-type parameter's name -TYPEwith symbolT. In template programming, you would generally useT- but that's a personal choice. You should better use a name that reflects the meaning of type-parameter, and that improves code readability. This symbol can be any name which follows variable naming rules in the C++ language.Secondly, I re-used the template parameterT- for both of arguments (n1andn2).Let's slightly modifyAddfunction, which would store the addition in local variable and then return the calculated value.template&lt;class T&gt;
T Add(T n1, T n2)
{
    T result;
    result = n1 + n2;returnresult;
}Quite explanatory, I used the type parameterTwithin the function's body. You might ask (you should): &quot;How the compiler would know what is type ofresult,when it tries to compile/parse the functionAdd?&quot;Well, while looking at the body of function template (Add), compiler wouldnotsee ifT(template type parameter) is correct or not. It would simply check for basic syntax (such as semi-colons, proper usage of keywords, matching braces etc), and would report errors for those basic checks. Again, it depends on compiler to compiler how it handles the template code - but it would not report any errors resulting due to template type parameters.Just for completeness, I would reiterate, compiler will not check if (currently relevant only for functionAdd):Tis having a default constructor (so thatT result;is valid)Tsupports the usage ofoperator +(so thatn1+n2is valid)Thas anaccessiblecopy/move-constructor (so thatreturnstatement succeeds)Essentially, the compiler would have to compile the template code in two phases: Once for basic syntax checks; and later foreach instantiationof function template - where it would perform actual code compilation against the template data-types.It is perfectly okay if you did not completely understood this two phase compilation process. You would get firm understanding as you read through this tutorial, and then you would come back to read these theory-sessions later!Pointers, References and Arrays with TemplatesFirst a code sample (No worries - it is simple code snippet!):template&lt;class T&gt;doubleGetAverage(T tArray[],intnElements)
{
    T tSum = T();//tSum = 0for(intnIndex =0; nIndex &lt; nElements; ++nIndex)
    {tSum += tArray[nIndex];}//Whatever type of T is, convert to doublereturndouble(tSum) / nElements;
}intmain()
{intIntArray[5] = {100,200,400,500,1000};floatFloatArray[3] = {1.55f,5.44f,12.36f};

    cout &lt;&lt; GetAverage(IntArray,5);
    cout &lt;&lt; GetAverage(FloatArray,3);
}For the first call ofGetAverage, whereIntArrayis passed, compiler would instantiate this function as:doubleGetAverage(inttArray[],intnElements);And similarly forfloat. The return type is kept asdoublesince average of numbers would logically fit indoubledata-type. Note that this is just for this example - the actual data-type that comes underTmay be a class, which may not be converted todouble.You should notice that a function template may have template type arguments, along with non-template type arguments. It it not required to have all arguments of a function template to arrive from template types.int nElementsis such function argument.Clearly note and understand that template type-parameter is justT, and notT*orT[]- compilers are smart enough to deduce the typeintfrom anint[](orint*). In the example given above, I have usedT tArray[]as an argument to function template, and actual data-type ofTwould intelligently be determined from this.Most often, you would come across and would also require to use initialization like:T tSum = T();First thing first, this is not template specific code - this comes under C++ language itself. It essentially means: Call thedefault constructorfor this datatype. Forint, it would be:inttSum =int();Which effectively initializes the variable with0. Similarly, forfloat, it would set this variable to0.0f. Though not covered yet, if a user defined class type comes fromT, it would call the default constructor of that class (If callable, otherwise relevant error). As you can understand thatTmight be any data-type, we cannot initializetSumsimply with an integer zero (0). In real case, it may be a some string class, which initializes it with empty string (&quot;&quot;).Since the template typeTmay be any type, it must also have+= operatoravailable. As we know, it is available for all basic data types (int,float,charetc.). If actual type (forT), doesn't have+=operator available (or any possibility), compiler would raise an error that actual type doesn't have this operator, or any possible conversion.Similarly, the typeTmust be able to convert itself todouble(see thereturnstatement). I will cover up these nitty-gritties, later. Just for better understanding, I am re-listing the requiredsupportfrom typeT(now, only applicable forGetAveragefunction template):Must have anaccessibledefault constructor.Must have+= operatorcallable.Must be able to convert itself todouble(or equivalent).ForGetAveragefunction template prototype, you may useT*instead ofT[], and would mean the same:template&lt;class T&gt;
GetAverage(T* tArray,intnElements){}Since the caller would be passing an array (allocated on stack or heap), or an address of a variable of typeT. But, as you should be aware, these rules comes under rule-book of C++, and not specifically from template programming!Moving ahead. Let's ask theactor'reference' to come into template programmingflick. Quite self-explanatory now, you just useT&amp;as a function template argument for the underlying typeT:template&lt;class T&gt;voidTwiceIt(T&amp; tData)
{
    tData *=2;//tData = tData + tData;}Which calculates the twice value of argument, and puts into same argument' value. You would call it simply as:intx =40;
TwiceIt(x);//Result comes as 80Note that I usedoperator *=to get twice of argumenttData. You may also useoperator +to gain the same effect. For basic data-types, both operators are available. For class type, not both operators would be available, and you might ask the class' to implement required operator.In my opinion, it is logical to askoperator +be defined by class. The reason is simple - doingT+Tis more appropriate for most UDTs (User Defined Type), than having*= operator. Ask yourself: What does it mean if some classStringorDateimplements, or is asked, to implement following operator:voidoperator*= (int);//void return type is for simplicity only.At this point, you now clearly understand that template parameter typeTmay be inferred fromT&amp;,T*orT[].Therefore, it is also possible and veryreasonableto addconstattribute to the parameter which is arriving to function template, and that parameter would not be changed by function template. Take it easy, it is as simple as this:template&lt;class TYPE&gt;voidPrintTwice(constTYPE&amp;data)
{
    cout&lt;&lt;"Twice: "&lt;&lt; data *2&lt;&lt; endl;
}Observe that I modified the template parameterTYPEtoTYPE&amp;, and also addedconstto it. Few or most of the readers would have realized the importance of this change. For those who didn't:TheTYPEtype may be large in size, and would demand more space on stack (call-stack). It includesdoublewhich requires 8 bytes*, some structure or a class, which would demand more bytes to be kept on stack. It essentially means - a new object of given type would be created, copy constructor called, and be put into call stack, followed by destructor call at then end of function.Addition of reference (&amp;) avoids all this -referenceof same object is passed.Function would not change the argument passed, and therefore addition ofconstto it. It ensures, to the caller of function, that this function (herePrintTwice), is not going to change the parameter's value. It also ensures a compiler error if, by mistake, the function itself tries to modify content of (constant) argument.*On 32-bit platform, function arguments would require 4-bytes minimum, and in multiple of 4-bytes. This means acharorshortwould require 4 bytes in call-stack. An 11-byte object, for example would require 12-bytes in stack.Similarly, for 64-bit platform, 8-bytes would be needed. An 11-byte object would require 16-bytes. Argument of typedoublewould need 8-bytes.All pointers/references takes 4-bytes/8-bytes respectively on 32-bit/64-bit platform, and therefore passingdoubleordouble&amp;would mean the same for 64-bit platform.And similarly, we should change other function templates as:template&lt;class TYPE&gt;
TYPE Twice(constTYPE&amp;data)//No change for return type{returndata *2;
}

template&lt;class T&gt;
T Add(constT&amp;n1,constT&amp; n2)//No return type change{returnn1 + n2;
}

template&lt;class T&gt;
GetAverage(constT tArray[],intnElements)//GetAverage(constT* tArray, int nElements){}Note that it is not possible to have reference andconstadded to return type, unless we intend to return reference (or pointer) of original object that was passed to the function template. The following code exemplifies it:template&lt;class T&gt;
T&amp; GetMax(T&amp; t1, T&amp; t2)
{if(t1 &gt; t2)
    {returnt2;
    }//elsereturnt2;
}It is how we utilize return reference:intx =50;inty =64;//Set the max value to zero (0)GetMax(x,y) =0;Note that this is just for illustration, and you would rarely see or write such code. You may, however see such code and may need to write, if the returned object is reference of some UDT. In that case member access operator dot (.) or arrow (-&gt;) would follow the function call. Anyway, this function template returns thereferenceof object which wins the greater-than race. This, definitely, requiresoperator&gt;be defined by typeT.You should have noticed, I have not addedconstto any of two parameters passed. This is required; since function returns non-const reference of typeT. Had it been like:T&amp; GetMax(constT&amp; t1,constT&amp; t2)At thereturnstatements, compiler would complain thatt1ort2cannot be converted to non-const. If we addconstto return type also (constT&amp; GetMax(...)), following line at call site would fail to compile:GetMax(x,y) =0;Sinceconstobject cannot be modified! You can definitely do forceful const/non-const typecasting, either in function or at call site. But that's a different aspect, a bad design and a non-recommended approach.Multiple Types with Function TemplatesTill now I have covered only one type as template type parameters. With templates, you may have more than one template-type parameters. It goes like:template&lt;class T1,classT2, ... &gt;WhereT1andT2are type-names to the function template. You may use any other specific name, rather thanT1,T2. Note that the usage of '...' above doesnotmean that this template specification can take any number of arguments. It is just illustration that template may have any number of arguments.(As with C++11 standard, templates would allow variable number of arguments - but that thing is out of topic, for now.)Let's have a simple example taking two template parameters:template&lt;class T1,classT2&gt;voidPrintNumbers(constT1&amp; t1Data,constT2&amp; t2Data)
{
     cout &lt;&lt;"First value:"&lt;&lt; t1Data;
     cout &lt;&lt;"Second value:"&lt;&lt; t2Data;
}And we can simply call it as:PrintNumbers(10,100);//int, intPrintNumbers(14,14.5);//int, doublePrintNumbers(59.66,150);//double, intWhere each call demands separate template instantiation for the first and second types being passed (or sayinferred). Therefore, following three function template instances would be populated by compiler://const and reference removed for simplicityvoidPrintNumbers(intt1Data,intt2Data);voidPrintNumbers(intt1Data,doublet2Data);voidPrintNumbers(doublet1Data,intt2Data);Realize that second and third instantiations are not same, asT1andT2would infer different data-types (int,doubleanddouble,int). Compiler willnotperform any automatic conversion, as it might do for normal function call - A normal function takingint, for example, may be passedshort, or vice-versa. But with templates, if you passshort- it is absolutelyshort, not (upgraded to)int. So, if you pass (short,int), (short,short), (long,int) - this would result in three different instantiations forPrintNumbers!In similar fashion, function templates may have 3 or more type parameters, and each of them would map to the argument types specified in function call. As an example, the following function template is legal:template&lt;class T1,classT2,classT3&gt;
T2 DoSomething(constT1 tArray[], T2 tDefaultValue, T3&amp; tResult)
{
   ... 
}WhereT1specifies the type of array that would be passed by caller. If array (or pointer) is not passed, compiler will render appropriate error. The typeT2is used as return type as well as second argument, which is passed by value. TypeT3is passed as reference (a non-const reference). This function template example given above is just haphazardly chosen, but is a valid function template specification.By now, I havestepped-upand elaborated multiple template parameters. But for a reason, I amstepping-downto one parameter function. There is a reason for this, and you will understand it in no time.Assume that there is a function (nontemplated), which takes anintargument:voidShow(intnData);And you call it as:Show(120);//1Show('X');//2Show(55.64);//3Call1is perfectly valid since function takesintargument, and we are passing120.Call2is valid call since we are passingchar, which will be promoted by compiler toint.Call3would demand demotion of value - compiler has to convertdoubletoint, and hence55would be passed instead of55.64. Yes, this will trigger appropriate compiler warning.One solution is to modify the function such that it takesdouble, where all three types can be passed. But that wouldn't support all types and may not fit in, or convertible to,double. Therefore, you may write set of overloaded functions, taking appropriate types. Armed with knowledge, now, you would appreciate the importance of templates, and would ask to write it a function template instead:template&lt;class Type&gt;voidShow(Type tData) {}Of course, assuming all existing overloads ofShowwere doing the same thing.Alright, you know this drill. So, what's new in this which caused me tostep-down?Well, what if you wanted to passintto function templateShow, but wish the compiler instantiates as ifdoublewas passed?//This will produce (instantiate) 'Show(int)'Show (1234);//But you want it to produce 'Show(double)'May seem illogical to demand this thing, as of now. But there is valid reason to demand such instantiation, which you will understand and appreciate soon!Anyway, first see how to demand such absurd thing:Show&lt;double&gt;(1234);Which instantiates the followingtemplate function(as you know):voidShow(double);With this special syntax (Show&lt;&gt;()), you are demanding compiler to instantiateShowfunction for the type being explicitly passed, and asking the compilernotto deduce type by function argument.Function Template - Template FunctionImportant! There is a difference betweenfunction templateandtemplate function.Afunction templateis body of a function that is bracketed aroundtemplatekeyword, which is not an actual function, and will not befullycompiled by compiler, and is not accountable by the linker. At least one call, for particular data-type(s) is needed to instantiate it, and be put into accountability of compiler and linker. Therefore, the instance of function templateShowis instantiated asShow(int)orShow(double).Atemplate function? Simply put, an &quot;instance of a function template&quot;, which is produced when you call it, or cause it to get instantiated for particular data type. The instance of function-template is actually a valid function.An instance of a function template (aka template-function) is not a normal function, under the umbrella of name-decoration system of compiler and linker. That means, an instance of function-template:template&lt;class T&gt;voidShow(T data) 
{ }for template argumentdouble, it isnot:voidShow(doubledata){}but actually:voidShow&lt;double&gt;(doublex){}For long, I did not uncover this, only for simplicity, and now you know it! Use your compiler/debugger to find out the actual instantiation of a function template, and see the full prototype of a function in call-stack or generated code.And hence, now you know the mapping between these two:Show&lt;double&gt;(1234);
...voidShow&lt;double&gt;(doubledata);//Note that data=1234.00, in this case!Explicit Template Argument SpecificationStepping back (up) to the multiple template argument discussion.We have following function template:template&lt;class T1,classT2&gt;voidPrintNumbers(constT1&amp; t1Data,constT2&amp; t2Data)
{}And have following function calls, causing 3 different instances of this function template:PrintNumbers(10,100);//int, intPrintNumbers(14,14.5);//int, doublePrintNumbers(59.66,150);//double, intAnd what if you just needed only one instance - both arguments takingdouble? Yes, you are willing to passints and let them be promoteddoubles. Coupled with the understanding you just gained, you would call this function-template as:PrintNumbers&lt;double, double&gt;(10,100);//int, intPrintNumbers&lt;double, double&gt;(14,14.5);//int, doublePrintNumbers&lt;double, double&gt;(59.66,150);//double, intWhich would produce only the followingtemplate function:voidPrintNumbers&lt;double, double&gt;(constdouble&amp; t1Data,constT2&amp; t2Data)
{}And the concept of passing template type parameters this way, from the call-site, is known asExplicit Template Argument Specification.Why would you need explicit type specification? Well, there are multiple reasons:You want only specific type to be passed, and not let the compilerintelligentlydeduceone or more template argument types solely by the actual arguments (function parameters).For example, there is one function template,max, takingtwoarguments (via onlyonetemplate type parameter):template&lt;class T&gt;
T max(T t1, T t2)
{if(t1 &gt; t2)returnt1;returnt2;
}And you attempt to call it as:max(120,14.55);It would cause a compiler error, mentioning there is an ambiguity with template-typeT. You are asking the compiler to deduce one type, from two types! One solution is to changemaxtemplate so that it takes two template parameters - but you aren't author of that function template.There you use explicit argument specification:max&lt;double&gt;(120,14.55);//Instantiates max&lt;double&gt;(double,double);Undoubtedly notice and understand that I have passed explicit specification only forfirsttemplate parameter, the second type is deduced from second argument of function call.When function-template takes template-type, but not from its function arguments.A simple example:template&lt;class T&gt;voidPrintSize()
{
   cout &lt;&lt;"Size of this type:"&lt;&lt;sizeof(T);
}You cannot call such function template simply as:PrintSize();Since this function template would require template type argument specification, and it cannot be deduced automatically by compiler. The correct call would be:PrintSize&lt;float&gt;();which would instantiatePrintSizewithfloattemplate argument.When function template has a return type, which cannot be deduced from arguments, or when function template doesn't have any argument.An example:template&lt;class T&gt;
T SumOfNumbers(inta,intb)
{
   T t = T();//Call default CTOR for Tt = T(a)+b;returnt;
}Which takes twoints, and sums them up. Though, summing them inintitself is appropriate, this function template givesopportunityto calculate the sum (usingoperator+) in any type as required by caller. For example, the get the result indouble, you would call it as:doublenSum;
nSum = SumOfNumbers&lt;double&gt;(120,200);The last two are just simplified examples for completeness, just to give you thehintwhere Explicit Template Argument Specification would fit in. There are more concrete scenarios where thisexplicitnesswould be needed, and would be covered in next part.Default Arguments with Function TemplatesFor readers, whodoknow about default template type specification in template' arena - this isnotabout default template-type arguments. Default template-types, is anyway, not allowed with function-templates. For readers, who donotknow about it, do not worry - this paragraph is not about default template type specification.As you know, a C++ function may have default arguments. The default-ness may only go from right to left, meaning, ifnthargument is required to be default, (n+1)thmust also be default, and so on till last argument of function.A simple example to explicate this:template&lt;class T&gt;voidPrintNumbers(Tarray[],intarray_size, T filter = T())
{for(intnIndex =0; nIndex &lt; array_size; ++nIndex)
   {if(array[nIndex] != filter)//Print if not filteredcout &lt;&lt;array[nIndex];
   }
}This function template would print, as you can guess, all numbers except which are filtered out by third argument:filter. The last, optional function argument, is defaulted to default-value of typeT, which, for all basic type would mean zero. Therefore, when you call it as:intArray[10] = {1,2,0,3,4,2,5,6,0,7};
PrintNumbers(Array,10);It would be instantiated as:voidPrintNumbers(intarray[],intarray_size,intfilter =int())
{}Thefilterargument would be rendered as:int filter = 0.As obvious, when you call it as:PrintNumbers(Array,10,2);The third argument gets value2, and not the default value0.It should be clearly understood that:TypeTmust have default constructor available. And of course, all operators as may be required by function body, for typeT.The default argument must bededuciblefrom the other non-default types the template takes. InPrintNumbersexample, type ofarraywould facilitate deduction forfilter.If not, you must use explicit template argument specification to specify type of default argument.For sure, the default argument may not necessarily be default value for typeT(pardon the pun). It means, the default-argument may not always need to depend on default-constructor of typeT:template&lt;class T&gt;voidPrintNumbers(Tarray[],intarray_size, T filter =T(60))Here, the default function argument doesn't use default-value for typeT. Instead, it uses value60. This, for sure, requires the typeTto have copy-constructor which accepts anint(for60).Finally, here comes an end to 'Function Templates' for this part of article. I assume you enjoyed reading and grasping thesebasicsof function templates. Next part would cover more intriguing aspects of Template programming.Class TemplatesMore often, you would design and use class templates, than function templates. In general, you use a class template to define an abstract type whose behavior is generic and is reusable, adaptable. While some text would start by giving example about data-structures like linked-lists, stacks, queues and similarcontainers. I would start with very basic examples, that are easy to understand.Let's take a simple class, which sets, gets and prints the value stored:classItem
{intData;public:
    Item() : Data(0)
    {}voidSetData(intnValue)
    { 
        Data = nValue;
    }intGetData()const{returnData;
    }voidPrintData()
    {
        cout &lt;&lt; Data;
    }
};One constructor which initializesDatato0, Set and Get methods, and a method to print current value. Usage is also quite simple:Item item1;
item1.SetData(120);
item1.PrintData();//Shows 120Nothing new for you, for sure! But when you need similar abstraction for other data-type, you need to duplicate code of entire class (or at least the required methods). It incurs code maintenance issues, increases code size at source code as well as at binary level.Yes, I can sense your intelligence that I am going to mention C++ templates! The templated version of the same class in form ofclass templateis as below:template&lt;class T&gt;classItem
{TData;public:
    Item() : Data(T())
    {}voidSetData(TnValue)
    {
        Data = nValue;
    }TGetData()const{returnData;
    }voidPrintData()
    {
        cout &lt;&lt; Data;
    }
};The class template declaration starts with same syntax as function templates:template&lt;class T&gt;classItemNote that the keywordclassis used two times - firstly to specify template type specification (T), and secondly to specify that this is a C++ class declaration.To completely turnIteminto a class template, I replaced all instances ofintwithT. I also usedT()syntax to call default constructor ofT, instead of hard-coded0(zero), in the constructor's initializer' list. If you've readfunction templatessection completely, you know the reason!And usage as also quite simple:Item&lt;int&gt;item1;
item1.SetData(120);
item1.PrintData();Unlike function template instantiation, where arguments of function itself helps the compiler to deduce template type arguments, with class templates you must explicitly pass template type (in angle brackets).The code snippet shown above causes class templateItemto instantiate asItem&lt;int&gt;. When you create another object with different type usingItemclass template as:Item&lt;float&gt; item2;floatn = item2.GetData();It would causeItem&lt;float&gt;to get instantiated. It is important to know that there is absolutely no relation between two instantiations of class template -Item&lt;int&gt;andItem&lt;float&gt;. For the compiler and linker, these two are different entities - or say, different classes.First instantiation with typeintproduces following methods:Item&lt;int&gt;::Item()constructorSetDataandPrintDatamethods for typeintSimilarly, second instantiation with typefloatwould produce:Item&lt;float&gt;::Item()constructorGetDatamethod forfloattypeAs you knowItem&lt;int&gt;andItem&lt;float&gt;are two different classes/types; and therefore, following code will not work:item1 = item2;//ERROR : Item&lt;float&gt; to Item&lt;int&gt;Since both types are different, the compiler will not callpossibledefault assignment operator. Haditem1anditem2were of same types (say both ofItem&lt;int&gt;), the compiler would happily call assignment operator. Though, for the compiler, conversion betweenintandfloatis possible, it is not possible for different UDT conversions, even if underlying data members are same - this is simple C++ rule.At this point, clearly understand that only following set of methods would get instantiated:Item&lt;int&gt;::Item()- constructorvoid Item&lt;int&gt;::SetData(int)methodvoid Item&lt;int&gt;::PrintData() constmethodItem&lt;float&gt;::Item()- constructorfloat Item&lt;float&gt;::GetData() constmethodThe following methods willnotget second phase compilation:int Item&lt;int&gt;::GetData() constvoid Item&lt;float&gt;::SetData(float)void Item&lt;float&gt;::PrintData() constNow, what is a second phase compilation? Well, as I already elaborated that template-code would be compiled for basic syntax checks, irrespective of it being called/instantiated or not. This is known as first-phase compilation.When you actually call, or somehow trigger it to be called, the function/method for the particular type(s) - then only it gets special treatment ofsecond-phasecompilation. Only through the second phase compilation, the code actually gets fully-compiled, against the type for which it is being instantiated.Though, I could have elaborated this earlier, but this place is appropriate. How do you find out if function is getting first-phase and/or second-phase compilation?Let's do something weird:T GetData()const{for())returnData;
 }There is an extra parenthesis at the end offor- which is incorrect. When you compile it, you would get host of errors,irrespectiveof it being called or not. I have checked it using Visual C++ and GCC compilers, and both complain. This validates first-phase compilation.Let's slightly change this to:T GetData()const{T temp = Data[0];//Index access ?returnData;
}Now compile itwithoutcallingGetDatamethod for any type - and there won't be any quench from the compiler. This means, at this point, this function doesn't get phase-two compilation treatment!As soon as you call:Item&lt;double&gt; item3;
item2.GetData();you would get error from compiler thatDatais not an array or pointer, which could haveoperartor []attached to it. It proves that only selected functions would get special privilege of phase-two compilation. And this phase-two compilation would happen separately for all unique types you instantiate class/function template for.One interesting thing, you can do is:T GetData()const{returnData%10;
}Which would get successfully compiled forItem&lt;int&gt;, but would fail forItem&lt;float&gt;:item1.GetData();//item1 is Item&lt;int&gt;//ERRORitem2.GetData();//item2 is Item&lt;float&gt;Sinceoperator %is not applicable forfloattype. Isn't it interesting?Multiple Types with Class TemplatesOur first class-templateItemhad only one template type. Now let's construct a class that would have two template-type arguments. Again, there could have been somewhat complex class template example, I would like to keep it simple.At times, you do require some native structure to keep few data members. Crafting a uniquestructfor the same appears somewhat needless and unnecessary-work. You would soon come out of names for different structures having few members in it. Also, it increases code length. Whatever your perspective may be for this, I am using it as an example, and deriving a class template having two members in it.STL programmers would find this as equivalent tostd::pairclass template.Assume you have a structurePoint,structPoint
{intx;inty;
};which is having two data-members. Further, you may also have another structureMoney:structMoney
{intDollars;intCents;
};Both of these structures have almost similar data-members in it. Instead of re-writing different structures, wouldn't it be better to have it at one place, which would also facilitate:Constructor having one or two arguments of given types, and a copy-constructor.Methods to compare two objects of same type.Swapping between two typesAnd more.You might say you can use inheritance model, where you'd define all required methods and let derive class customize it. Does it fit in? What about the data-types you chosen? It might beint,string, orfloat,some-classas types.In short, inheritance will only complicate the design, and will not allow plug-in feature facilitated by C++ templates.There we use class templates! Just define a classtemplatefor two types, having all required methods. Let's start!template&lt;classType1,classType2&gt;structPair
{//In public area, since we want the client to use them directly.Type1first;Type2second;
};Now, we can usePairclass template toderiveany type having two members. An example://Assume as Point structPair&lt;int,int&gt;point1;//Logically same as X and Y memberspoint1.first=10;
point1.second=20;Understand that type offirstandsecondare nowintandint, respectively. This is because we instantiatedPairwith these types.When we instantiate it like:Pair&lt;int, double&gt; SqRoot;

SqRoot.first =90;
SqRoot.second =9.4868329;firstwould be ofinttype, andsecondwould be ofdoubletype. Clearly understand thatfirstandsecondare data-members, and not functions, and therefore there is no runtime penalty ofassumedfunction call.Note: In this part of article, all definitions are within the class declaration body only. In next part, I would explain how to implement methods in separate implementation file, and issues related with that. Therefore, all method definitions shown should be assumed withinclass ClassName{...};only.The following given default constructor would initialize both members to their default values, as per data type ofType1andType2:Pair() :first(Type1()), second(Type2()){}Following is a parameterized constructor takingType1andType2to initialize values offirstandsecond:Pair(constType1&amp; t1,constType2&amp; t2) :first(t1), second(t2){}Following is a copy-constructor which would copy onePairobject from anotherPairobject, of exactly same type:Pair(constPair&lt;Type1, Type2&gt;&amp; OtherPair) : 
  first(OtherPair.first),
  second(OtherPair.second)
 {}Please note that it is very much required to specify template type arguments ofPair&lt;&gt;, for the argument of this copy-constructor. The following specification wouldn't make sense, sincePairisnota non-template type:Pair(constPair&amp; OtherPair)//ERROR: Pair requires template-typesAnd here is an example using parametrized constructor and copy-constructor:Pair&lt;int,int&gt; point1(12,40);
Pair&lt;int,int&gt; point2(point1);It is important to note that if you change any of the template type parameters of either of the objects,point2orpoint1,you wouldn't be able to copy-construct it usingpoint1object. Following would be an error:Pair&lt;int,float&gt; point2(point1);//ERROR: Different types, no conversion possible.Though, there is a possible conversion betweenfloattoint, but there is no possible conversion betweenPair&lt;int,float&gt;toPair&lt;int,int&gt;. The copy constructor cannot take othertypeas copyable object. There is a solution to this, but I would discuss it in next part.In similar fashion, you can implement comparison operators to compare two objects of samePairtype. Following is an implementation of equal-to operator:booloperator== (constPair&lt;Type1, Type2&gt;&amp; Other)const{returnfirst == Other.first &amp;&amp; 
         second == Other.second;
}Note that I usedconstattribute, for argument and for the method itself. Please fully understand the first line of above' method definition!Just like copy-constructor call, you must pass exactly the same type to this comparison operator - compiler will not attempt to convert differentPairtypes. An example:if(point1 == point2)//Both objects must be of same type....For a solid understanding for the concepts covered till here, please implement following methods by on your own:All remaining 5 relational operatorsAssignment operatorSwapmethodModify both constructors (except copy-constructor), and combine them into one so that they take both parameters as default. This means, implement only one constructor that can take 0,1 or 2 arguments.Pairclass is an example for two types, and it can be used instead of defining multiple structures having just two data-members. The drawback is just with remembering whatfirstandsecondwould mean (X or Y?). But when you well-define a template instantiation, you would always know and usefirstandsecondmembers appropriately.Ignoring this one disadvantage, you would achieve all the features in theinstantiatedtype: constructors, copy-constructor, comparison operators, swap method etc. And, you'd get all this without re-writing the required code for various two-member structures you would need. Furthermore, as you know, only the set ofrequiredmethods would get compiled and linked. A bug fix in class template would automatically be reflected to all instantiations. Yes, a slight modification to class template may also raise bunch of errors, of other types, if the modification fails to comply with existing usage.Likewise, you can have a class templatetuplewhich allows three (or more) data-members. Please try to implement classtuplewith three members (first,second,third) by yourself:template&lt;class T1,classT2,classT3&gt;classtupleNon-type Template ArgumentsAlright, we have seen that class templates, just like function templates, can take multiple type arguments. But class templates also allow few non-type template arguments. In this part, I will elaborate only one non-type:integer.Yes, a class template may take a integer as template argument. First a sample:template&lt;class T,intSIZE&gt;classArray{};In this class template declaration,int SIZEis a non-type argument, which is an integer.Only integral data-types can be non-type integer argument, it includesint,char,long,long long,unsignedvariants andenums. Types such asfloatanddoubleare not allowed.When being instantiated, only compile time constant integer can be passed. This means100,100+99,1&lt;&lt;3etc are allowed, since they are compiled time constant expressions. Arguments, that involve function call, likeabs(-120), are not allowed.As a template argument, floats/doubles etc may be allowed, if they can be converted to integer.Fine. We can instantiate class templateArrayas:Array&lt;int, 10&gt; my_array;So what? What's the purpose ofSIZEargument?Well, within the class template you can use this non-type integer argument, wherever you could have used an integer. It includes:Assigning static const data-member of a class.template&lt;class T,intSIZE&gt;classArray
{staticconstintElements_2x = SIZE *2; 
};[First two lines of class declaration will not be shown further, assume everything is within class' body.]Since it is allowed to initialize astatic-constant-integerwithin class declaration, we can use non-type integer argument.To specify default value for a method.(Though, C++ also allows any non-constant to be a default parameter of a function, I have pointed this one for just for illustration.)voidDoSomething(intarg = SIZE);//Non-const can also appear as default-argument...To define the size of an array.This one is important, and non-type integer argument is often used for this purpose. So, let's implement the class templateArrayutilizingSIZEargument.private:T TheArray[SIZE];Tis the type of array,SIZEis the size (integer) - as simple as that. Since the array is in private area of class, we need define several methods/operators.//Initialize with default (i.e. 0 for int)voidInitialize()
{for(intnIndex =0; nIndex &lt; SIZE; ++nIndex)
        TheArray[nIndex] = T();
}For sure, the typeTmust have a default constructor and an assignment operator. I will cover these things (requirements) for function template and class templates in next part.We also need to implement array-element access operators. One of the overloaded index-access operator sets, and the other one gets the value (of typeT):Toperator[](intnIndex)const{if(nIndex&gt;0 &amp;&amp; nIndex&lt;SIZE)
  {returnTheArray[nIndex];
  }returnT();
}

T&amp;operator[](intnIndex)
{returnTheArray[nIndex];
}Note that first overload (which is declaredconst) is get/read method, and has a check to see if index is valid or not, otherwise returns default value for typeT.The second overload returns thereferenceof an element, which can be modified by caller. There is no index validity check, since it has to return a reference, and therefore local-object (T()) cannot be returned. You may, however, check the index argument, return default value, useassertion and/or throw an exception.Let's define another method, which wouldlogicallysum all the elements ofArray:T Accumulate()const{
  T sum = T();for(intnIndex =0; nIndex &lt; SIZE; ++nIndex)
  {
     sum += TheArray[nIndex];
  }returnsum;
}As you can interpret, it requiresoperator+=to be available for target typeT. Also note that return type isTitself, which is appropriate. So, when instantiateArraywith some string class, it will call+=on each iteration and would return the combined string. If target type doesn't have this+=operator defined, and you call this method, there would be an error. In that case, you either - don't call it; or implement the required operator overload in the target class.Template Class as Argument to Class TemplateWhile it is a vague statement to understand, and invites some ambiguities, I would attempt my best to remove the fogginess.First, recollect the difference betweentemplate-functionand afunction-template. If theneuronshave helped to transfer the correct information to thecacheof your brain-box, you nowcallbackthat template-function is an instance of function-template. If search-subsystem of your brain is not responding, pleasereload the informationagain!An instance ofclass templateistemplate class.Therefore, for following class template:template&lt;class T1,classT2&gt;classPair{};The instantiation of this template is a template-class:Pair&lt;int,int&gt; IntPair;Clearly understand thatIntPairisnota template-class, isnotinstantiation for class template. It is anobjectof a particular instantiation/class-template. The template-class/instantiation isPair&lt;int,int&gt;, which produces another class type (compiler, our friend does this, you know!). Essentially this is what template-class would be produced by compiler for this case:classPair&lt;int,int&gt;{};There is more precise definition for a template-class, select this single line of code for easy understanding. Detailed explication would come in next installment of this series.Now, let's come to the point. What if you pass a template-class to some class-template? I mean, what does it mean by following statement?Pair&lt;int,Pair&lt;int,int&gt;&gt; PairOfPair;Is it valid - if so, what does it mean?Firstly, it is perfectly valid. Secondly, it instantiatestwotemplate classes:Pair&lt;int,int&gt;-APair&lt;int,Pair&lt;int,int&gt;&gt;--BBothAandBtypes would be instantiated by compiler, and if there is any error, arising due to any type of these two template classes, compiler would report. To simplify thiscomplexinstantiation, you may do:typedefPair&lt;int,int&gt; IntIntPair;
...
Pair&lt;int,IntIntPair&gt; PairOfPair;You can assignfirstandsecondmembers ofPairOfPairobject like this:PairOfPair.first =10;
PairOfPair.second.first =10;
PairOfPair.second.second=30;Note thatsecondmember in last two lines is of typePair&lt;int,int&gt;, and therefore it has same set of members to be accessed further. That's the reasonfirstandsecondmembers can be used, incascadedmanner.Now you (hopefully) understand that class template (Pair) is taking template-class (Pair&lt;int,int&gt;)as argument and inducing the final instantiation!An interesting instantiation, in this discussion, would be ofArraywithPair! You know thatPairtakes two template type arguments, andArraytakes one type argument, and a size (integer) argument.Array&lt;Pair&lt;int, double&gt;,40&gt; ArrayOfPair;Hereintanddoubleare type-arguments forPair. Hence, the first template-type ofArray(marked bold) isPair&lt;int,double&gt;. The second argument is constant40. Can you answer this: Would the constructor ofPair&lt;int,double&gt;be called? When it will be called? Before you answer that, I just reverse the instantiation as:Pair&lt;int, Array&lt;double, 50&gt;&gt; PairOfArray;Wohoo! What does it mean?Well, it means:PairOfArrayis an instantiation ofPair, which is taking first type asint(forfirstmember), and second type (second) is anArray. WhereArray(the second type ofPair) is50elements of typedouble!Don't kill me for this! Slowly and clearly understand these basic concepts of templates. Once you get the crystal-clear understanding, you wouldlovetemplates!Here again, I used a template-class (Array&lt;double,50&gt;) as an argument to an instance of other type (Pair&lt;int,...&gt;).Okay, but what right-shift operator (&gt;&gt;) is doing above? Well, that's not an operator, but just ending ofArray's type specification, followed by ending ofPairtype specification. Some old compilers required us to put a space in between two greater-than symbols, so to avoid error or confusion.Pair&lt;int, Array&lt;double, 50&gt;  &gt; PairOfArray;At present, almost all modern C++ compilers are smart enough to understand that this is used to end template type specification, and therefore you need not to worry. Therefore, you may freely use two or more&gt;symbols to end template specification(s).Kindlynote that passing a template class (instantiation) is nothing very specific in C++ terms - it is just a type that a class template would take.Finally, Here I put usage examples both objects. First the constructors.Array&lt; Pair&lt;int, double&gt;, 40&gt; ArrayOfPair;This will cause the constructor ofPairto be called40times, since there is declaration of constant-size array inArrayclass template:T TheArray[SIZE];Which would mean:Pair&lt;int,double&gt; TheArray[40];And hence the required number of calls to constructor ofPair.For the following object construction:Pair&lt;int, Array&lt;double, 50&gt;&gt; PairOfArray;The constructor ofPairwould initialize first argument with0(usingint()notation), and would call constructor ofArraywithArray()notation, as shown below:Pair() : first(int()), second(Array())
 {}Since the default constructor ofArrayclass template is provided by compiler, it would be called. If you don't understand the stuff written here, please sharpen your C++ skills.Assigning one element ofArrayOfPair:ArrayOfPair[0] = Pair&lt;int,double&gt;(40,3.14159);Here, you are calling non-const version ofArray::operator[], which would return thereferenceof first element ofArray(fromTheArray). The element, as you know, is of typePair&lt;int,double&gt;. The expression on right side of assignment operator is just calling the constructor forPair&lt;int,double&gt;and passing required two arguments. The assignment is done!Default Template Arguments with Class TemplatesFirst let me eliminate any ambiguity with 'Default Argument' phrase. The same phrase was used in Function Template section. In that sub-section, the default-argument referred to arguments of function parameters itself, not the type-arguments of function template. Function templates, anyway, donotsupport default arguments for template-arguments. As a side note, please know that methods of a class template can take default arguments, as any ordinary function/method would take.Class templates, on other hand, do support default-argument for the type/non-type arguments for the template parameters. Throwing you an example:template&lt;class T,intSIZE=100&gt;classArray
{private:
   T TheArray[SIZE];
   ...
};I have just modified aroundSIZEin first line for class templateArray. The second template parameter, an integer constant specification, is now set to100. It means, when you use it in following manner:Array&lt;int&gt; IntArray;It would essentially mean:Array&lt;int,100&gt; IntArray;Which would be automatically placed by compiler during the instantiation of this class template. Of course, you can specify custom array size by explicitly passing the second template argument:Array&lt;int,200&gt; IntArray;Do remember that when you explicitly pass the default argument's parameter, with the same argument specified in class template declaration, it would instantiate it only once. By this, I mean, the following two objects created would instantiate only one class:Array&lt;int,100&gt;Array&lt;int&gt; Array1;
Array&lt;int,100&gt; Array2;Of course, if you change the default' template parameter in class template definition, with value other than100, it would cause two template instantiations, since they would be different types.You can customize the default argument by usingconstor#define:constint_size=120;//#define_size150template&lt;class T,intSIZE=_size&gt;classArrayFor sure, using_sizesymbol instead of hard-coded constant value mean the same. But using a symbol would ease the default' specification. Irrespective of how you specify the default template parameter for integer (which is a non-type template argument), it must be a compile time constant expression.You would generallynotuse default specification for non-type integer parameter, unless you are utilizing templates for advanced stuff, like meta-programming, static-asserts, SFINAE etc, which definitely demands a separate part. More often you would see and implement default parameters for class templates, which aredata-types. An example:template&lt;classT =int&gt;classArray100
{
    T TheArray[100];
};It defines an array of typeTof size100. Here, the type argument is defaulted toint. That means, if you don't specify the type while instantiatingArray100, it would map toint. Following is an example on how to use it:Array100&lt;float&gt; FloatArray;
Array100&lt;&gt;IntArray;In the first instantiation, I passedfloatas template type, and in second call I kept it default (toint), by using&lt;&gt;notation. While there are more uses of this notation in template programming, which I would cover up in later parts, it is very much required for this case also. If you try to use the class template as:Array100 IntArray;It would result in compiler errors, sayingArray100requires template parameters. Therefore, you must use empty-set of angle-brackets (&lt;&gt;) to instantiate a class template, if all template arguments are default, and you wish to use defaults.Important thing to remember is that a non-template class of nameArray100willnotbe allowed also. Definition of a non-template class like as given below, along with template class (above or below each other), will upset the compiler:classArray100{};//Array100 demands template arguments!Now, let's mix both type and non-type argument in our classArray:template&lt;class T=int,intSIZE=100&gt;classArray
{
    T TheArray[SIZE];
    ...
};Finally, both type and the size arguments are marked default withintand100respectively. Clearly understand that firstintis for default specification ofT, and secondintis for non-template constant specification. For simplicity and better readability, you should keep them in different lines:template&lt;class T=int,intSIZE=100&gt;classArray{};Now, use use your intelligence to parse the meaning of following instantiations:Array&lt;&gt;            IntArray1;
Array&lt;int&gt;         IntArray2;
Array&lt;float, 40&gt;   FlaotArray3;Just likeexplicit specification in function templates, specifying only the trailing template arguments is not allowed. Following is an error:Array&lt;, 400&gt; IntArrayOf500;//ERRORAs a final note, do remember that following two object creations would instantiate only one class template, since essentially they are exactly the same:Array&lt;&gt;          IntArray1;
Array&lt;int&gt;       IntArray2
Array&lt;int, 100&gt;  IntArray3;Defaulting a template type on another typeIt is also possible to default a type/non-type parameter on a previously arrived template parameter. For instance, we can modify thePairclass so that second type would be same as first type, if second type is not explicitly specified.template&lt;class Type1,classType2 = Type1&gt;classPair
{
    Type1 first;
    Type2 second;
};In this modified class templatePair,Type2now defaults toType1type. An instantiation example:Pair&lt;int&gt; IntPair;Which, as you can guess, is same as:Pair&lt;int,int&gt; IntPair;But saves you from typing the second parameter. It is also possible to let the first argument ofPairbe default also:template&lt;class Type1=int,classType2 = Type1&gt;classPair
{
    Type1 first;
    Type2 second;
};Which means, if you don't pass any template argument,Type1would beint, and henceType2would also beint!The following usage:Pair&lt;&gt; IntPair;Instantiates following class:classPair&lt;int,int&gt;{};For sure, it is also possible to default non-type arguments on another non-type argument. An example:template&lt;class T,intROWS =8,intCOLUMNS = ROWS&gt;classMatrix
{
    T TheMatrix[ROWS][COLUMNS];
};But, thedependenttemplate parameter must be on therightof which it is dependent upon. Following would cause errors:template&lt;class Type1=Type2,classType2 =int&gt;classPair{};

template&lt;class T,intROWS = COLUMNS,intCOLUMNS = 8&gt;classMatrixClass' Methods as Function TemplatesThough, this one isn't for absolute beginners, but since I have covered both function templates and class templates - the elaboration of this concept is logical for this first part of this series itself.Consider a simple example:classIntArray
{intTheArray[10];public:template&lt;typename T&gt;voidCopy(T target_array[10]){for(intnIndex =0; nIndex&lt;10; ++nIndex)
       {
          target_array[nIndex] = TheArray[nIndex];//Better approach://target_array[nIndex] = static_cast&lt;T&gt;(TheArray[nIndex]);}
    }
};The classIntArrayis simple, non-template class, having an integer array of10elements. But the methodCopyis a designed as a function template (method template?). It takes one template type parameter, which would be deduced by compiler automatically. Here is how we can use it:IntArray int_array;floatfloat_array[10];

int_array.Copy(float_array);As you can guess,IntArray::Copywould be instantiated with typefloat, since we are passing float-array to it. To avoid confusion and understand it better, just think ofint_array.CopyasCopyonly, andIntArray::Copy&lt;float&gt;(..)asCopy&lt;float&gt;(..)only. Themethodtemplate of a class is nothing but an ordinary function template embedded in a class.Do notice that I used10as array size everywhere. Interestingly, we can also modify the class as:template&lt;intARRAY_SIZE&gt;classIntArray
{intTheArray[ARRAY_SIZE];public:
    template&lt;typename T&gt;voidCopy(T target_array[ARRAY_SIZE])
    {for(intnIndex =0; nIndex&lt;ARRAY_SIZE; ++nIndex)
       {
            target_array[nIndex] = static_cast&lt;T&gt;(TheArray[nIndex]);
       }
    }
};Which makes the classIntArrayand the methodCopy, better candidates to be in the realm of template programming!As you would have intelligently guessed,Copymethod is nothing but an array-conversion routine, which converts fromintto any type, wherever conversion fromintto given type is possible. This is one of the valid case where class method can be written as function templates, taking template arguments by themselves. Please modify thisclass templateso that it can work for any type of array, not justint.For sure, 'explicit template argument specification' with method template is also possible. Consider another example:template&lt;class T&gt;classConvert
{   
   T data;public: 
   Convert(constT&amp; tData = T()) : data(tData)
   { }template&lt;class C&gt;boolIsEqualTo(constC&amp; other )const{returndata == other;   
   }
};Which can be utilized as:Convert&lt;int&gt; Data;floatData2 =1;boolb =Data.IsEqualTo(Data2);It instantiatesConvert::IsEqualTowithfloatparameter. Explicit specification, as given below, would instantiate it withdouble:boolb = Data.IsEqualTo&lt;double&gt;(Data2);One of the astounding thing, with the help of templates, you can do it by defining conversion operator on top of template!template&lt;class T&gt;operatorT()const{returndata;
}It would make possible to convert theConvert' class template instance into any type, whenever possible. Consider following usage example:Convert&lt;int&gt; IntData(40);floatFloatData;doubleDoubleData;FloatData = IntData;
DoubleData = IntData;Which would instantiate following two methods (fully qualified names):Convert&lt;int&gt;::operator&lt;float&gt;float();
Convert&lt;int&gt;::operator&lt;double&gt;double();On one hand it provides good flexibility, since without writing extra code,Convertcan convert itself (the specific instantiation) to any data-type - whenever conversion is possible at compilation level. If conversion is not possible, like fromdoubleto string-type, it would raise an error.But on the other hand, it also invites trouble by possibility of inadvertently inserting bugs. You may not want to have conversion operator called, and it is called (compiler code generated) without you knowing about it.At The EndYou have just seen slight glimpse of power and flexibility provided by templates. Next part will cover more of advanced and intriguing concepts. My humble and aspiring request to all readers is toplaymore and more with templates. Try to gain firm understanding on one aspect first (like function template only), rather than just hastily jumping to other concept. Initially do it with yourtestprojects/code-base, and not with any existing/working/production code.Following is a summary of what we have covered:To avoid unnecessary code duplication and code maintenance issues, specially when code is exactly same, we can use templates. Templates are far better approach than using C/C++ macros or functions/classes running on top of void-pointers.Templates are not only type-safe, but also reduces unnecessary code-bloat which would not be referred (not generated by compiler).Function templates are used to put a code that is not a part of class, and is same/almost-same for different data-types. At most of the places, compiler would automatically determine the type. Otherwise you have to specify the type, or you may also specify explicit type yourself.Class templates makes it possible to wrap any data type around specific implementation. It may be an array, string, queue, linked-list, thread-safeatomicimplementation etc. Class templates do facilitate default template type specification, which function template don't support.Hope you have enjoyed the article, and cleared out the mental-block that templates are complicated, unnecessarily, bizarre. Second part would be arriving soon!HistoryFirst release: October 8, 2011 -Covered basics of templates in C++, function templates.First amendment: Oct 9, 2011 -Class Templates and multiple types in class templates, non-template typeThird amendment: Oct 11, 2011 -Template class as argument to class templateFourth amendment: Oct 12, 2011 -Default Template Arguments with Class TemplatesFifth amendment: Oct 13, 2011 - Methods as Function Templates, finishing lines.Sixth amendment: Mar 8, 2012 - Basic corrections.License